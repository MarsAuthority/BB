<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://mars.run/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://mars.run/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Mars’ Blog | 记录·分享·回顾</title>
    <link>https://mars.run/</link>
    <description>开源工具、效率方法、心理学探索的自我提升笔记，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Wed, 22 Feb 2023 05:05:01 GMT</pubDate>
    <lastBuildDate>Wed, 22 Feb 2023 05:05:01 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by Mars</copyright>
    <image>
      <title>Mars’ Blog | 记录·分享·回顾</title>
      <url>https://mars.run/logo.svg</url>
      <link>https://mars.run/</link>
    </image>
    <category>日常折腾</category>
    <category>安全通讯 Newsletter</category>
    <category>代码学习</category>
    <category>网络安全</category>
    <category>知识管理</category>
    <category>工具</category>
    <item>
      <title>摄影作品</title>
      <link>https://mars.run/family/%E6%91%84%E5%BD%B1%E4%BD%9C%E5%93%81.html</link>
      <guid>https://mars.run/family/%E6%91%84%E5%BD%B1%E4%BD%9C%E5%93%81.html</guid>
      <source url="https://mars.run/rss.xml">摄影作品</source>
      <description>丁丁</description>
      <category>日常折腾</category>
      <pubDate>Fri, 11 Jun 2021 23:00:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 丁丁</h2>
<!-- markdownlint-disable -->
<div class="image-preview">
  <img src="https://mars0run.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2e419e54-a89c-40ad-8d1b-c5a12dd82c62%2FUntitled.png?id=f6471d78-e4d5-42de-8a96-a851b9cf4826&amp;table=block&amp;spaceId=7472f6c4-ea2e-45de-b643-908ef53dae3e&amp;width=2000&amp;userId=&amp;cache=v2">
  <img src="https://mars0run.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffd069322-ad08-4d20-bafb-093f9259c299%2FUntitled.png?id=5abf1225-a2bf-4cb5-8e96-6cfced367c04&amp;table=block&amp;spaceId=7472f6c4-ea2e-45de-b643-908ef53dae3e&amp;width=2000&amp;userId=&amp;cache=v2">
</div>
<br>
<div class="image-preview">
  <img src="https://mars0run.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2acad466-cc41-4f56-ab9f-7d057491f28d%2FUntitled.png?id=07957ea9-0236-4bd0-86ef-3fcb8979a0fb&amp;table=block&amp;spaceId=7472f6c4-ea2e-45de-b643-908ef53dae3e&amp;width=1960&amp;userId=&amp;cache=v2">
  <img src="https://mars0run.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Feb80ce03-c0ee-4f60-9564-8d2acb208076%2FUntitled.png?id=d59e5491-4c72-4fd8-949f-11005c878598&amp;table=block&amp;spaceId=7472f6c4-ea2e-45de-b643-908ef53dae3e&amp;width=1960&amp;userId=&amp;cache=v2">
</div>
<br>
<div class="image-preview">
  <img src="https://mars0run.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa65a9deb-55fe-4af9-ac88-922e2ef5be20%2FUntitled.png?id=5654f382-e1a5-46a8-8c42-f96bcd8a1a0c&amp;table=block&amp;spaceId=7472f6c4-ea2e-45de-b643-908ef53dae3e&amp;width=2000&amp;userId=&amp;cache=v2">
  <img src="https://mars0run.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F52c0ae9b-98e9-45da-b573-ac35643f398d%2FUntitled.png?id=308add7d-4208-4862-999d-b63dcf274f14&amp;table=block&amp;spaceId=7472f6c4-ea2e-45de-b643-908ef53dae3e&amp;width=2000&amp;userId=&amp;cache=v2">
</div>
<!-- markdownlint-restore -->]]></content:encoded>
    </item>
    <item>
      <title>折纸作品</title>
      <link>https://mars.run/family/%E6%8A%98%E7%BA%B8%E4%BD%9C%E5%93%81.html</link>
      <guid>https://mars.run/family/%E6%8A%98%E7%BA%B8%E4%BD%9C%E5%93%81.html</guid>
      <source url="https://mars.run/rss.xml">折纸作品</source>
      <description>Gallery</description>
      <category>日常折腾</category>
      <pubDate>Tue, 11 Jun 2019 23:00:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Gallery</h2>
<!-- markdownlint-disable -->
<div class="image-preview">
  <img class="col3" src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/aHjSCA.jpg">
  <img class="col3" src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/qCpGHx.jpg">
  <img class="col3" src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/70pfTU.jpg">
</div>
<br>
<div class="image-preview">
  <img class="col3" src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/qwSdp5.jpg">
  <img class="col3" src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/eR9ktj.jpg">
  <img class="col3" src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/Y7Vyis.jpg">
</div>
<!-- markdownlint-restore -->]]></content:encoded>
    </item>
    <item>
      <title>Security.News@202206</title>
      <link>https://mars.run/newsletter/Security.News@202206.html</link>
      <guid>https://mars.run/newsletter/Security.News@202206.html</guid>
      <source url="https://mars.run/rss.xml">Security.News@202206</source>
      <description>安全事件 LockBit 勒索软件的团伙声称已经入侵了网络安全公司 Mandiant，该公司正在调查所谓的安全事件 本月早些时候，Mandiant 公司发布了一份报告，称网络犯罪团伙“邪恶公司”(Evil Corp) 转用 LockBit 2.0勒索软件来逃避制裁；之后，LockBit 勒索软件团伙将网络安全公司 Mandiant 列入其黑网泄露网站公布的受害者名单。Mandiant 正在调查勒索软件团伙的说法，这个网络犯罪团伙宣称从该公司盗取了356841文件，并计划在网上泄露这些文件。 Mandiant 公司迅速回应了记者的置评请求，并发表声明称: “ Mandiant 公司知道这些与 lockbit 相关的声明。在这一点上，我们没有任何证据支持他们的说法。我们将继续密切关注事态发展。”</description>
      <category>安全通讯 Newsletter</category>
      <pubDate>Sun, 05 Jun 2022 16:23:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 安全事件</h2>
<h3> LockBit 勒索软件的团伙声称已经入侵了网络安全公司 Mandiant，该公司正在调查所谓的安全事件</h3>
<p>本月早些时候，Mandiant 公司发布了一份报告，称网络犯罪团伙“邪恶公司”(Evil Corp) 转用 LockBit 2.0勒索软件来逃避制裁；之后，LockBit 勒索软件团伙将网络安全公司 Mandiant 列入其黑网泄露网站公布的受害者名单。Mandiant 正在调查勒索软件团伙的说法，这个网络犯罪团伙宣称从该公司盗取了356841文件，并计划在网上泄露这些文件。
Mandiant 公司迅速回应了记者的置评请求，并发表声明称: “ Mandiant 公司知道这些与 lockbit 相关的声明。在这一点上，我们没有任何证据支持他们的说法。我们将继续密切关注事态发展。”
<img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/JLtatI.jpg" alt="JLtatI" loading="lazy"></p>
<blockquote>
<p>等待更多细节披露，持续跟进中</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://financialpost.com/technology/lockbit-claims-mandiant-data-will-be-published-mandiant-says-no-evidence-of-theft" target="_blank" rel="noopener noreferrer">https://financialpost.com/technology/lockbit-claims-mandiant-data-will-be-published-mandiant-says-no-evidence-of-theft</a></li>
</ul>
<h3> 一个网络罪犯团队在4个月内偷走了100万 Facebook 账户凭证</h3>
<p>2021年底，防网络钓鱼公司 Pixm 的安全研究人员发现，这项钓鱼攻击事件从去年Q4才开始，但已经证明非常成功。在 Pixm 发现的大约400个登陆页面中，仅仅一个在2021年就有270万的访问量，并且在2022年已经骗取了850万的访问量。
Pixm 确定了大约400个独特的钓鱼页面; 对其中17个页面的随机分析显示，平均浏览量为985,228页。推算到400页，你会得到399,017,673次访问。“我们估计，迄今为止确定的400个用户名，以及他们所有独特的钓鱼网页，只代表了这个活动的一小部分,”Pixm 说。</p>
<blockquote>
<p>攻击者使用合法的站点托管网站（例如 <a href="http://glitch.me" target="_blank" rel="noopener noreferrer">glitch.me</a>、 <a href="http://Famous.co" target="_blank" rel="noopener noreferrer">Famous.co</a>、<a href="http://amaze.co" target="_blank" rel="noopener noreferrer">amaze.co</a>、<a href="http://funnel-preview.com" target="_blank" rel="noopener noreferrer">funnel-preview.com</a> 等）来绕过Facebook的检测，通过Facebook Messager传播，这种模式对于基于URL信誉度的传统解决方案是毁灭性打击的，而基于内容的检测可能是因为成本过大而无法大规模应用。这种模式的攻击已经非常成熟了，历史上经典的案例包括：Github Page、Google Translate、Azure Blob 存储、Amazon&nbsp;Cloudfront等。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://pixmsecurity.com/blog/blog/phishing-tactics-how-a-threat-actor-stole-1m-credentials-in-4-months/" target="_blank" rel="noopener noreferrer">https://pixmsecurity.com/blog/blog/phishing-tactics-how-a-threat-actor-stole-1m-credentials-in-4-months/</a></li>
<li><a href="https://www.theregister.com/2022/06/09/facebook_phishing_campaign/" target="_blank" rel="noopener noreferrer">https://www.theregister.com/2022/06/09/facebook_phishing_campaign/</a></li>
<li><a href="https://www.proofpoint.com/us/threat-insight/post/threat-actors-abuse-github-service-host-variety-phishing-kits" target="_blank" rel="noopener noreferrer">https://www.proofpoint.com/us/threat-insight/post/threat-actors-abuse-github-service-host-variety-phishing-kits</a></li>
</ul>
<h3> AMD服务的450GB数据被窃取</h3>
<p>勒索集团 RansomHouse 声称，AMD 员工使用的“123456”等简单密码使窃取数据变得容易。
根据 <a href="https://techcrunch.com/2022/06/28/amd-extortion-ransomhouse/" target="_blank" rel="noopener noreferrer">TechCrunch</a> 的报道，他们已经看到了一些被盗的数据，RansomHouse不是在开玩笑，密码很简单。AMD 的员工显然是依靠密码，如“password”，“123456”和“Welcome1”来保护他们的帐户。我们都知道这不是个好主意。</p>
<blockquote>
<p>弱口令是老生常谈的话题了，没想到2022年了，AMD居然还在使用这些密码。
简单统计了下RansomHouse公开的数据，共xx条记录，其中password 89条，P@ssw0rd 72条，Amd!23 31条，Welcome1 21条，p@ssw0rd1 9条。
有意思的是，键盘漫游模式的密码也出现了好几次，具体可以看这里 <a href="https://twitter.com/PyroTek3/status/1473036483661553669" target="_blank" rel="noopener noreferrer">https://twitter.com/PyroTek3/status/1473036483661553669</a></p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://techcrunch.com/2022/06/28/amd-extortion-ransomhouse/" target="_blank" rel="noopener noreferrer">https://techcrunch.com/2022/06/28/amd-extortion-ransomhouse/</a></li>
</ul>
<h2> 行业动态</h2>
<h3> 以色列网络安全创业公司 Talon 在 RSA 大会上被评为“最具创新力”</h3>
<p>RSA 公司周二宣布，信息安全事件 RSA 会议已经将以色列的 Talon Cybersecurity 评为年度 RSAC 创新沙盒大赛的获胜者。
Talon 被评为“最具创新性的初创企业”，由一组评委选出，创造了业内第一个安全的企业浏览器，使企业能够简化其安全程序，同时提供安全和改进的混合工作体验。</p>
<blockquote>
<p>云上安全一般可以分为两类：保护企业云上自有业务，以及保护员工安全的访问云上业务。考虑到国外企业大量使用Web服务或SaaS服务，各类业务事实上就是Web服务或SaaS形态，所以后者的场景可以泛化为保护员工访问各类外部服务。
从Talon的白皮书可以看出，它已经将自己定位成一款Web应用和SaaS的网关类产品，同时提供了运行时隔离、零信任、数据防泄露等能力。
浏览器可以是天然的零信任agent。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://talon-sec.com/resources/whitepapers/white-paper-an-enterprise-browser-for-the-digital-business/" target="_blank" rel="noopener noreferrer">https://talon-sec.com/resources/whitepapers/white-paper-an-enterprise-browser-for-the-digital-business/</a></li>
<li><a href="http://blog.nsfocus.net/rsa2022-talon-cyber-security-win/" target="_blank" rel="noopener noreferrer">http://blog.nsfocus.net/rsa2022-talon-cyber-security-win/</a></li>
</ul>
<h3> 美国 HHS 安全风险评估工具发布3.3版本</h3>
<p>美国卫生与公众服务部(HHS)民权办公室(OCR)和国家卫生信息技术协调员(ONC)发布了安全风险评估(SRA)工具3.3版。SRA“旨在帮助医疗保健提供者按照 HIPAA 安全规则和医疗保险和医疗补助服务中心(CMS)电子健康记录(EHR)激励计划的要求进行安全风险评估。”</p>
<blockquote>
<p>民权办公室 (OCR) 和国家卫生信息技术协调员办公室 (ONC)开发了 SRA 工具，以帮助 HIPAA 涵盖的实体根据HIPAA 安全规则导航风险评估要求。
SRA 工具的受众主要包括中小型供应商，可能不适用于较大的组织；内容主要为政策和合规为主，做起来比实际的安全防御/控制能力建设要简单许多。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://healthitsecurity.com/news/onc-ocr-release-updated-version-of-hhs-security-risk-assessment-sra-tool" target="_blank" rel="noopener noreferrer">https://healthitsecurity.com/news/onc-ocr-release-updated-version-of-hhs-security-risk-assessment-sra-tool</a></li>
<li><a href="https://www.healthit.gov/topic/privacy-security-and-hipaa/security-risk-assessment-tool" target="_blank" rel="noopener noreferrer">https://www.healthit.gov/topic/privacy-security-and-hipaa/security-risk-assessment-tool</a></li>
</ul>
<h2> 行业报告</h2>
<h3> 黑客组织Gallium使用新的难以检测的远程访问木马</h3>
<p>Unit 42最近发现了一种新的、难以检测的远程访问木马程序，名为 PingPull，正在被一个叫做进阶持续性渗透攻击(APT)的组织 GALLIUM 使用。
PingPull 具有利用三种协议(ICMP、 HTTP (S)和原始 TCP)进行命令和控制(C2)的能力。尽管使用 ICMP 隧道并不是一种新技术，PingPull 使用 ICMP 使得检测其 C2通信变得更加困难，因为很少有组织在其网络上实现对 ICMP 流量的检查。</p>
<blockquote>
<p>之前就有人使用ICMP/DNS隧道来免费上网，就是利用运营商/网管无法对这些协议进行计费认证，且难以禁止使用的空子来实现的。作为防守方，我们不光要监控常用的TCP/UDP，更应该对ICMP/DNS的使用额外关注，这里往往会成为检测盲点。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://unit42.paloaltonetworks.com/pingpull-gallium/" target="_blank" rel="noopener noreferrer">https://unit42.paloaltonetworks.com/pingpull-gallium/</a></li>
<li><a href="https://zgao.top/%E5%88%A9%E7%94%A8ptunnel%E5%BB%BA%E7%AB%8Bicmp%E9%9A%A7%E9%81%93%E5%AE%9E%E7%8E%B0%E8%81%94%E9%80%9A%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%85%8D%E6%B5%81/" target="_blank" rel="noopener noreferrer">https://zgao.top/利用ptunnel建立icmp隧道实现联通校园网免流/</a></li>
</ul>
<h2> TTPs动态</h2>
<h3> 使用悬挂 iframe 绕过 CSP</h3>
<p>CSP 将about:blank URL 视为同源（同源策略），当攻击者将跨域 iframe 设置为 about:blank 时，它就变得可以被攻击者读取；虽然Chrome之前针对<strong><strong>Dangling markup injection</strong></strong>的缓解措施有一定的用处，但通过滥用浏览器特性，可以绕过这些缓解措施，并通过注入获得跨域信息——即使在你的 CSP 中禁用了 JavaScript。</p>
<blockquote>
<p>portswigger真的是把web安全玩透了，一直可以从他们这里学到各种新姿势、新思路。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://portswigger.net/research/bypassing-csp-with-dangling-iframes" target="_blank" rel="noopener noreferrer">https://portswigger.net/research/bypassing-csp-with-dangling-iframes</a></li>
</ul>
<h2> 学习资源</h2>
<h2> Google chronicle提供的一些学习资源</h2>
<p>探索 Chronicle 资源，包括白皮书、网络研讨会、案例研究和数据表。</p>
<blockquote>
<p>值得仔细看看，竞品分析必备良器。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://chronicle.security/knowledge-base/" target="_blank" rel="noopener noreferrer">https://chronicle.security/knowledge-base/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/JLtatI.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>理解PHP内存管理</title>
      <link>https://mars.run/code/%E7%90%86%E8%A7%A3PHP%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</link>
      <guid>https://mars.run/code/%E7%90%86%E8%A7%A3PHP%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</guid>
      <source url="https://mars.run/rss.xml">理解PHP内存管理</source>
      <description>内存管理概述 内存管理，是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。 在使用C/C++开发程序的时候，需要格外注意内存管理，申请了内存再使用完后要记得释放，否则可能会造成内存泄漏。如果程序需要常驻内存，那么内存泄漏问题会把机器的内存耗光。所以在PHP这种需要常驻内存的程序来说，内存管理非常重要，它决定了程序的稳定性和执行效率。另外，应用程序向系统申请内存，释放内存的时候会引发系统调用，系统调用提供用户程序与操作系统之间的接口，他会触发0x80 号中断（int 0x80）将CPU从用户态切换到内核态，执行完毕再切换回用户态。在PHP这种对性能要求较高的程序来说，频繁在用户态和内核态切换会带来很大的性能消耗。</description>
      <category>代码学习</category>
      <pubDate>Tue, 28 Jun 2016 11:11:12 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 内存管理概述</h2>
<p>内存管理，是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</p>
<p>在使用C/C++开发程序的时候，需要格外注意内存管理，申请了内存再使用完后要记得释放，否则可能会造成内存泄漏。如果程序需要常驻内存，那么内存泄漏问题会把机器的内存耗光。所以在PHP这种需要常驻内存的程序来说，内存管理非常重要，它决定了程序的稳定性和执行效率。另外，应用程序向系统申请内存，释放内存的时候会引发系统调用，系统调用提供用户程序与操作系统之间的接口，他会触发0x80 号中断（int 0x80）将CPU从用户态切换到内核态，执行完毕再切换回用户态。在PHP这种对性能要求较高的程序来说，频繁在用户态和内核态切换会带来很大的性能消耗。</p>
<p>介于以上原因，PHP实现了自己的内存管理器（ZendMM）, 所以在编写PHP脚本的时候我们不需要对内存进行管理。</p>
<h2> ZendMM</h2>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PHP的内存管理是分层的，它分为三层：存储层（storage）、堆层（heap）和接口层（emalloc/efree）。存储层通过 malloc()、mmap() 等函数向系统真正的申请内存，并通过 free() 函数释放所申请的内存。存储层通常一次申请大量内存，这样接口层在需要分配空间的时候，通过堆层将存储层申请到的内存进行拆分，按照大小给接口层使用。在存储层共有4种内存分配方案: malloc，win32，mmap_anon，mmap_zero。默认使用malloc分配内存，如果设置了ZEND_WIN32宏，则为windows版本，调用HeapAlloc分配内存。并且PHP的内存方案可以通过设置变量来修改。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>借用一张图来说明一下：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/4PFj1W.jpg" alt="4PFj1W" tabindex="0" loading="lazy"><figcaption>4PFj1W</figcaption></figure>
<p>内存分配有两种类型：</p>
<ol>
<li>small, 为了速度和效率。</li>
<li>large, 为了不造成浪费。</li>
</ol>
<p>内存分配有两种生命周期：</p>
<ol>
<li>request，最常见的情况，只需要满足当前请求的内存需求，一次请求结束之后就free。</li>
<li>persistent，需要被分配比单个请求持续时间更长的一段时间的内存，这种情况下使用操作系统的malloc来分配内存，这些分配的内存并不会添加ZendMM使用的那些额外的信息，从而实现永久分配。</li>
</ol>
<p>ZendMM提供的request内存分配相关函数：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ZendMM提供的persistent内存分配相关函数：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 存储层（storage）</h2>
<p>存储层（storage）是向系统真正的申请内存，它的作用是将内存分配的方式对堆层透明化。我们先看看它的结构。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看看存储层（storage）的初始化函数zend_mm_startup():</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中mem_handlers里面是4种内存分配方案：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/4r26LI.jpg" alt="4r26LI" tabindex="0" loading="lazy"><figcaption>4r26LI</figcaption></figure>
<h2> 堆层（heap）</h2>
<p>我们先看看heap的结构：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中free_buckets 和 large_free_buckets 是关键，它们分别是小块内存列表和大块内存列表，在接口层申请内存的时候，ZendMM会在heap层中搜索合适大小的内存块，small类型的使用free_buckets，large类型则使用large_free_buckets，如果都没有足够的内存的话，就使用rest_buckets。经过以上步骤还没有合适的资源的话，使用ZEND_MM_STORAGE_ALLOC函数向系统再申请一块内存。</p>
<p>之前的zend_mm_startup()函数调用zend_mm_startup_ex()来初始化堆层（heap），这里我们只说一下其中的zend_mm_init()，我们看看它的实现：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们先看看鸟哥画的Heap结构图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/TJ6pEQ.jpg" alt="TJ6pEQ" tabindex="0" loading="lazy"><figcaption>TJ6pEQ</figcaption></figure>
<p>再回到zend_mm_init()，这里同时初始化free_buckets 和 large_free_buckets。其实他们就像Hashtable一样，每个bucket也对应一定大小的内存块列表。</p>
<p>free_buckets使用宏<code>ZEND_MM_SMALL_FREE_BUCKET</code>来管理分配小块内存：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>free_buckets是一个数组指针，它存储的是指向zend_mm_free_block结构体的指针，他们以两个为一对，分别存储双向链表的头尾指针。如图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/DDTZ3s.jpg" alt="DDTZ3s" tabindex="0" loading="lazy"><figcaption>DDTZ3s</figcaption></figure>
<p>这里的初始化非常巧妙，我们先看看<code>ZEND_MM_SMALL_FREE_BUCKET</code>，它是将free_buckets列表的偶数位的内存地址(也就是指向prev_free_block的地址)加上两个指针的内存大小并减去zend_mm_small_free_block结构所占空间的大小。而因为zend_mm_free_block结构和zend_mm_small_free_block结构的差距在于两个指针，所以他的计算结果就是free_buckets列表index对应双向链表的第一个zend_mm_free_block的prev_free_block地址减8的地址。为什么是减8的地址？因为zend_mm_free_block的前8个字节是zend_mm_block_info，之后才是prev_free_block。两个结构体如下：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了方面理解，看下图。我们假设index为0的情况，&amp;heap-&gt;free_buckets[0] 的地址为0x881260，加上sizeof(zend_mm_free_block*)*&nbsp;2 再减去sizeof(zend_mm_small_free_block))的结果 0x881258，它是&amp;heap-&gt;free_buckets[0]地址减8的地址，它指向的结构体 zend_mm_free_block，所以p-&gt;prev_free_block指向的就是0x881260，也就是heap-&gt;free_buckets[0]。</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/b87C4t.jpg" alt="b87C4t" tabindex="0" loading="lazy"><figcaption>b87C4t</figcaption></figure>
<p>接着后面的代码：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个循环中，free_buckets的偶数位index，将其next_free_block和prev_free_block都指向自己，通过两个指针的大小(sizeof(zend_mm_free_block*)*&nbsp;2)实现数组元素的向后移动，index 0-&gt;2-&gt;4-&gt;……-&gt;62 。这种不存储zend_mm_free_block数组，仅存储其指针的方式不可不说精妙。虽然在理解上有一些困难，但是节省了内存。鸟哥是这样说的：</p>
<blockquote>
<p>this is a tricky way to store ZEND_MM_NUMER_BUCKET into a fixed length array.
and only the prev_free_block and next_free_block will be use in that way, looking at the picture above, the red box.
so actually there is same ZEND_MM_NUMBER_BUCKET buckets stored in the free_buckets array.</p>
</blockquote>
<p>所以上一张图所示的free_buckets，在经过初始化后，内容为：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/qgXzU4.jpg" alt="qgXzU4" tabindex="0" loading="lazy"><figcaption>qgXzU4</figcaption></figure>
<h1> <strong><strong>接口层（emalloc/efree）</strong></strong></h1>
<p>PHP实现了emalloc、efree等函数，当程序需要内存的时候，ZendMM会在内存池中分配相应的内存，这样避免了PHP向系统频繁的内存申请操作，节省了系统开销。</p>
<p>ZendMM在分配内存主要是有以下步骤：</p>
<p><strong>1：</strong>&nbsp;计算出ture_size，即内存对齐。如果所需要的内存的大小的低三位不为0（不能为8整除），则将低三位加上7，并与~7进行按位与操作，即对于大小不是8的整数倍的内存大小补全到可以被8整除。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2：</strong>&nbsp;通过<code>ZEND_MM_MAX_SMALL_SIZE</code>判断出内存大小类型是small还是large，如果是small，则跳到3，large跳到6。(之前也有写到，小于272Byte的内存为小块内存)</p>
<p><strong>3：</strong>&nbsp;计算出要申请的内存大小对应的index。</p>
<p>它的相关函数(即需要分配的内存大小对应的index)为：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在默认情况下，ZEND_MM_ALIGNMENT = 8，ZEND_MM_ALIGNMENT_LOG2 = 3，ZEND_MM_ALIGNED_MIN_HEADER_SIZE = 16。通过这个宏可以知道，内存大小与index的关系是：</p>
<table>
<thead>
<tr>
<th>内存大小</th>
<th>index</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 - 23</td>
<td>0</td>
</tr>
<tr>
<td>24 - 31</td>
<td>1</td>
</tr>
<tr>
<td>32 - 39</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>264 - 271</td>
<td>31</td>
</tr>
</tbody>
</table>
<p>所以，小于272Byte的内存为小块内存。如果大于271Byte的话，则index为32，会使free_buckets数组越界。这样，ZendMM就可以快速定位到最可能适合的区域来查找，提高性能。就像哈希函数一样。</p>
<p><strong>4：</strong>&nbsp;如果Cache存在的话，即heap→cache[index]存在，则使用这片cache。（CACHE默认开启）</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>**5：**如果未找到Cache，则从free_buckets查找是否存在空闲内存。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**5.1：**首先看看free_buckets中剩余的内存是否满足true_size。（将heap-&gt;free_bitmap 右移index次，不为0则有空闲内存）</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**5.2：**根据内存大小找到最小块内存。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里说一下zend_mm_low_bit和zend_mm_high_bit。他们就像哈希函数一样，将不同大小的内存映射到不同的index，使ZendMM快速定位，提高性能。</p>
<p>zend_mm_low_bit实现如下：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看汇编和后面的C语言实现的方式就懂了，即bit scan forward，从低位向高位扫描，返回遇到1的比特位数。比如：bitmap为52(00110100)，那么返回值为2。可以看出，ZEND_MM_BUCKET_INDEX和zend_mm_low_bit结合起来，才是free_buckets的hash映射函数。</p>
<p>zend_mm_high_bit则为large_free_buckets的hash映射函数。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>zend_mm_high_bit是bit scan reverse，也是从低位向高位扫描，但它是返回遇到最高位1的比特位数。比如：bitmap为512(1000000000)，那么返回值为9。</p>
<p><strong>5.3：</strong>&nbsp;成功分配内存并返回。</p>
<p><strong>6：</strong>&nbsp;如果free_buckets没有找到合适的内存，则进入zend_mm_search_large_block，在large_free_buckets中寻找合适的内存。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>**6.1：**使用前面说过的宏ZEND_MM_LARGE_BUCKET_INDEX，来查找true_size对应的large_free_buckets。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>**6.2：**和之前小块内存分配的逻辑一样，看看large_free_buckets中剩余的内存是否满足true_size。（将heap-&gt;free_bitmap 右移index次，不为0则有空闲内存）</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**6.3：**看看large_free_buckets[index]是否存在可用的内存。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>large_free_buckets是一种字典树，如果large_free_buckets[index]中的内存大小和true_size相等，则返回这块内存。</p>
<p>如果没有找到大小相等的内存，则寻找最小的“大块内存”。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>p = p→child[p→child[0] != NULL]</code>&nbsp;，是寻找最小的block。</p>
<p><strong>7：</strong>&nbsp;如果free_bucket和large_free_buckets都没有找到合适的内存，那么只好去搜索rest_buckets了。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**8：**如果以上都没有合适的内存的话（有可能是初始化的时候，或者内存不足的情况），申请一块段内存。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后将这块新segment的第一块block作为best_fit使用。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>segment的结构如下图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/0LGJRs.jpg" alt="0LGJRs" tabindex="0" loading="lazy"><figcaption>0LGJRs</figcaption></figure>
<p>**9：**最后，将新的block放入large_free_buckets/free_buckets/rest_buckets。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过zend_mm_add_to_free_list可以看到large_free_bucket和free_buckets的分配方式。如果new_free_block是大块内存，则将它分配到large_free_buckets。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>large_free_buckets的结构如下图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/cE8Ivb.jpg" alt="cE8Ivb" tabindex="0" loading="lazy"><figcaption>cE8Ivb</figcaption></figure>
<p>下面，说说ZendMM在释放内存的过程，跟分配内存的过程相反：</p>
<p><strong>1：</strong>&nbsp;如果p是一个合法的指针，计算其对应的block，和block的大小。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**2：**如果size是小块内存且cache未满(最大ZEND_MM_CACHE_SIZE)，计算其对应的index，将mm_block放入cache[index]。（CACHE默认开启，其中ZEND_MM_SMALL_SIZE、ZEND_MM_BUCKET_INDEX在前面分配内存的时候讲过）</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**3：**如果size是大块内存或者cache已满，且mm_block的前一块或者后一块block是空闲块，则调用zend_mm_remove_from_free_list将其删除（将下一个节点/上一节点合并）。如果mm_block为segment的第一块，则使用zend_mm_del_segment删除这个segment。否则就使用zend_mm_add_to_free_list将mm_block加入large_free_buckets/free_buckets/rest_buckets。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中zend_mm_remove_from_free_list也只是将large_free_buckets/free_buckets/rest_buckets中mm_block的相关指针销毁，将回收到内存池中。</p>
<h2> 小结</h2>
<p>PHP的内存管理实现了自己的内存池，使得PHP内核在真正使用内存之前，先申请一块内存，当我们申请内存时就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存，提高了内存分配的效率。PHP还实现了垃圾回收机制（Garbage Collection）及写时复制（Copy On Write）以进一步优化。</p>
<p>以上文章仅仅是我个人(当然主要还是那些参考资料)的理解，有什么错误的地方还请指正。</p>
<h2> 参考资料</h2>
<ol>
<li><a href="http://www.kancloud.cn/kancloud/php-internals/42794" target="_blank" rel="noopener noreferrer">http://www.kancloud.cn/kancloud/php-internals/42794</a></li>
<li><a href="https://wiki.php.net/internals/zend_mm" target="_blank" rel="noopener noreferrer">https://wiki.php.net/internals/zend_mm</a></li>
<li><a href="http://www.phppan.com/php-source-analytics/" target="_blank" rel="noopener noreferrer">http://www.phppan.com/php-source-analytics/</a></li>
<li><a href="http://www.laruence.com/2011/11/09/2277.html" target="_blank" rel="noopener noreferrer">http://www.laruence.com/2011/11/09/2277.html</a></li>
<li><a href="https://github.com/php/php-src/blob/PHP-5.4/Zend/zend_alloc.c" target="_blank" rel="noopener noreferrer">https://github.com/php/php-src/blob/PHP-5.4/Zend/zend_alloc.c</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/4PFj1W.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>安全工具库</title>
      <link>https://mars.run/cybersecurity/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%BA%93.html</link>
      <guid>https://mars.run/cybersecurity/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%BA%93.html</guid>
      <source url="https://mars.run/rss.xml">安全工具库</source>
      <description>Red Team Bypass LOLBAS GTFOBins PoC Same Origin Method Execution Generator</description>
      <category>网络安全</category>
      <pubDate>Mon, 19 Dec 2022 23:10:10 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Red Team</h2>
<h3> Bypass</h3>
<ul>
<li><a href="https://lolbas-project.github.io/" target="_blank" rel="noopener noreferrer">LOLBAS</a></li>
<li><a href="https://gtfobins.github.io/" target="_blank" rel="noopener noreferrer">GTFOBins</a></li>
</ul>
<h3> PoC</h3>
<ul>
<li><a href="https://www.someattack.com/Playground/SOMEGenerator" target="_blank" rel="noopener noreferrer">Same Origin Method Execution Generator</a></li>
</ul>
<h2> Blue Team</h2>
<h3> 日常运营</h3>
<ul>
<li><a href="https://cyberchef.org/" target="_blank" rel="noopener noreferrer">cyberchef</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Security.News@202205</title>
      <link>https://mars.run/newsletter/Security.News@202205.html</link>
      <guid>https://mars.run/newsletter/Security.News@202205.html</guid>
      <source url="https://mars.run/rss.xml">Security.News@202205</source>
      <description>供应链/开源软件安全 开源安全基金会和 Linux 基金会呼吁1.5亿美元来改善开源安全 亚马逊、爱立信、谷歌、英特尔、微软和 VMWare 已经承诺提供3000万美元。更多资金已经在路上了，亚马逊AWS已经承诺额外提供1000万美元。 以下是开源行业致力于实现的十个目标。 安全教育: 向所有人提供基线安全软件开发教育和认证。 风险评估: 为前10,000(或更多) OSS 组件建立一个公开的、供应商中立的、基于客观度量的风险评估仪表板。 数字签名: 加快采用软件版本的数字签名。 内存安全: 通过替换非内存安全语言来消除许多漏洞的根本原因。 事件响应: 建立 OpenSSF 开源安全事件响应小组，安全专家可以在关键时刻协助开源项目响应漏洞。 更好的扫描: 通过先进的安全工具和专家指导，加速维护人员和专家发现新的漏洞。 代码审计: 每年对多达200个最关键的开放源码软件组件进行一次第三方代码审查(以及任何必要的补救工作)。 数据共享: 协调整个行业的数据共享，以改进有助于确定最关键 OSS 组件的研究。 软件物料清单(SBOMs) : 到处改进 SBOM 的工具和培训，以推动采用。 改进的供应链: 通过更好的供应链安全工具和最佳实践，加强10个最关键的供应链/开源软件构建系统、包管理器和分销系统。</description>
      <category>安全通讯 Newsletter</category>
      <pubDate>Thu, 05 May 2022 16:23:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 供应链/开源软件安全</h2>
<h3> <strong>开源安全基金会和 Linux 基金会呼吁1.5亿美元来改善开源安全</strong></h3>
<p>亚马逊、爱立信、谷歌、英特尔、微软和 VMWare 已经承诺提供3000万美元。更多资金已经在路上了，亚马逊AWS已经承诺额外提供1000万美元。</p>
<ul>
<li>以下是开源行业致力于实现的十个目标。
<ol>
<li>安全教育: 向所有人提供基线安全软件开发教育和认证。</li>
<li>风险评估: 为前10,000(或更多) OSS 组件建立一个公开的、供应商中立的、基于客观度量的风险评估仪表板。</li>
<li>数字签名: 加快采用软件版本的数字签名。</li>
<li>内存安全: 通过替换非内存安全语言来消除许多漏洞的根本原因。</li>
<li>事件响应: 建立 OpenSSF 开源安全事件响应小组，安全专家可以在关键时刻协助开源项目响应漏洞。</li>
<li>更好的扫描: 通过先进的安全工具和专家指导，加速维护人员和专家发现新的漏洞。</li>
<li>代码审计: 每年对多达200个最关键的开放源码软件组件进行一次第三方代码审查(以及任何必要的补救工作)。</li>
<li>数据共享: 协调整个行业的数据共享，以改进有助于确定最关键 OSS 组件的研究。</li>
<li>软件物料清单(SBOMs) : 到处改进 SBOM 的工具和培训，以推动采用。</li>
<li>改进的供应链: 通过更好的供应链安全工具和最佳实践，加强10个最关键的供应链/开源软件构建系统、包管理器和分销系统。</li>
</ol>
</li>
</ul>
<blockquote>
<p>从Strust2、Heartbleed、Solarwinds到Log4j，可以看到供应链/开源软件的漏洞影响是多么深远，现在越来越多的科技巨头加入治理，希望能改善供应链/开源软件这块“金三角”；对应国内类似的相关治理建议，可以参考CNCERT的《2021 年开源软件供应链安全风险研究报告》。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://www.zdnet.com/article/white-house-joins-openssf-and-the-linux-foundation-in-securing-open-source-software/" target="_blank" rel="noopener noreferrer">https://www.zdnet.com/article/white-house-joins-openssf-and-the-linux-foundation-in-securing-open-source-software/</a></li>
<li><a href="https://www.cert.org.cn/publish/main/upload/File/2021%20Risk%20Analysis%20Report%20of%20Open%20Source%20Software%20%20.pdf" target="_blank" rel="noopener noreferrer">https://www.cert.org.cn/publish/main/upload/File/2021 Risk Analysis Report of Open Source Software  .pdf</a></li>
</ul>
<h3> Google宣布成立“开源维护组”</h3>
<p>在这次会议（前面提到的OpenSSF会议）上，Google宣布成立新的“开源维护小组”——一个由Google工程师组成的敬业团队，他们将与上游维护者紧密合作，提高关键开源项目的安全性。除了这一举措，我们还提出了一些想法，并参与了关于提高开放源码软件的安全性和可信度的讨论。</p>
<ul>
<li>Google提出了一个用于解决开源漏洞的框架：了解，预防，修复；希望在推进和改进软件供应链安全的事业中产生动力。
<ol>
<li>了解：我们“了解”的目标是捕获更精确的漏洞数据，建立一个标准模式来跟踪跨数据库的漏洞，并创建工具来更好地跟踪依赖关系。
在 Log4j 漏洞响应期间，google 支持的 <a href="https://deps.dev/" target="_blank" rel="noopener noreferrer">Open Source Insights</a> 项目帮助社区<a href="https://security.googleblog.com/2021/12/understanding-impact-of-apache-log4j.html" target="_blank" rel="noopener noreferrer">了解漏洞的影响</a>。</li>
<li>预防：为了帮助用户了解新依赖项的风险，以便他们能够对所使用的包和组件做出明智的决策。
我们已经看到社区在预防漏洞方面的强有力的参与，尤其是在安全记分卡项目中。<a href="https://securityscorecards.dev/" target="_blank" rel="noopener noreferrer">Scorecards</a> 评估项目遵守安全最佳实践的情况，并为开发人员在使用依赖项之前可以参考的评分进行分配。</li>
<li>修复：为了帮助用户理解他们的选择，以消除漏洞，使通知能够帮助加速修复，并修复受影响软件的广泛使用的版本，而不仅仅是最新的版本。
Google去年为开源项目提供了1500万美元。这包括750万美元，用于供应链安全、模糊、内核安全和关键基础设施安全等领域的定向安全工作。</li>
</ol>
</li>
</ul>
<blockquote>
<p>谷歌是开源的最大商业用户之一，如果没有开源软件，Google的大部分服务都不会存在。
其实整个互联网行业都是开源软件的最大受益者，但它们已经白嫖习惯了……</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://blog.google/technology/safety-security/shared-success-in-building-a-safer-open-source-community/" target="_blank" rel="noopener noreferrer">https://blog.google/technology/safety-security/shared-success-in-building-a-safer-open-source-community/</a></li>
</ul>
<h2> 行业动态</h2>
<h3> 阿里云云原生蜜罐重磅发布</h3>
<p>HoneyPot技术由来已久，通过诱饵资产与用户真实资产混合部署，提升内网感
知力、并增加攻击复杂度，是打破攻防不对等的重要手段。</p>
<ul>
<li>但是，传统蜜罐欺骗防御方案往往因为成本、真实度等问题不能实现高覆盖，形成“不可能三角〞。
<img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/dYd6gT.jpg" alt="阿里云云原生蜜罐" loading="lazy"></li>
</ul>
<p>云蜜罐使用四大技法，打破不可能：</p>
<ol>
<li>VPC黑洞探针</li>
<li>主流应用类型全覆盖</li>
<li>伪装程度随心配置</li>
<li>联动防御与溯源反制</li>
</ol>
<blockquote>
<p>云原生蜜罐的优势在于微服务架构的高灵活性和可维护性，利用云平台设施实现快速部署和弹性伸缩；AWS Marketplace上已经有了很多支持云原生的蜜罐产品。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://developer.aliyun.com/article/927892" target="_blank" rel="noopener noreferrer">https://developer.aliyun.com/article/927892</a></li>
<li><a href="https://aws.amazon.com/marketplace/search?searchTerms=honeypot" target="_blank" rel="noopener noreferrer">https://aws.amazon.com/marketplace/search?searchTerms=honeypot</a></li>
</ul>
<h3> 雾帜智能发布《国内SOAR领域首个Top 10安全剧本最佳实践》</h3>
<p>我们邀请过去3年中部分已经部署或即将部署雾帜SOAR（HoneyGuide）的客户进行了一对一的访谈。在本次访谈中，我们一共收集了将近400个在用剧本。我们的专家团队对这400个剧本和我们已有的剧本仓库中的100多个剧本模板，总计约500个剧本进行了统计、分析和评估。最终，我们从中整理了10个被认为通用且最有价值的优秀剧本，借本次产品发布会的机会分享给大家。这些剧本涵盖事件响应、漏洞管理和应急预案等多个方面，希望能抛砖引玉，与大家探讨SOAR剧本的最佳实践。</p>
<ul>
<li>剧本列表
<img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/RETRHL.jpg" alt="剧本列表" loading="lazy"></li>
</ul>
<blockquote>
<p>看到SOAR平台，我的第一反应就是低代码平台，如Node-RED，但根据Gartner对SOAR最新的定义，强调了SOAR是一种为人提供机器协助的解决方案，重点在人与流程（People and Process），而不是单纯的编排与自动化工具；或许可以称之为SOA for human。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://www.secrss.com/articles/24043" target="_blank" rel="noopener noreferrer">https://www.secrss.com/articles/24043</a></li>
</ul>
<h3> 美国国家安全局和其盟友发布网络安全建议</h3>
<p>CISA 在 NSA 和其他合作伙伴的帮助下制定了该建议。 其中包括 FBI、加拿大网络安全中心 (CCCS)、新西兰国家网络安全中心 (NCSC-NZ) 和计算机应急响应小组 (CERT NZ)、荷兰国家网络安全中心 (NCSC-NL)，以及 英国国家网络安全中心（NCSC-UK）就该咨询。 许多相同的网络安全机构在 4 月 27 日合作发布了补充公告，其中强调了自 2021 年以来最常被利用的漏洞。</p>
<ul>
<li>NSA推荐的七大安全最佳实践
<ul>
<li>访问控制</li>
<li>加固凭据</li>
<li>日志集中管理</li>
<li>使用防病毒软件</li>
<li>部署检测工具</li>
<li>使用安全配置操作在可访问 Internet 的主机上公开的服务</li>
<li>保持软件更新</li>
</ul>
</li>
</ul>
<blockquote>
<p>里面大多数建议都可以在CIS Critical Controls中看到，相当于一个MVP（最小可用产品）。
引用赵彦在《从Google白皮书看企业安全最佳实践》中提到的一句话：没有业界安全大会上那些花俏的概念和名词，全都是正统的安全设计思路，以既有的简单的安全手段解决复杂的问题。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://media.defense.gov/2022/May/17/2002998718/-1/-1/0/CSA_WEAK_SECURITY_CONTROLS_PRACTICES_EXPLOITED_FOR_INITIAL_ACCESS.PDF" target="_blank" rel="noopener noreferrer">https://media.defense.gov/2022/May/17/2002998718/-1/-1/0/CSA_WEAK_SECURITY_CONTROLS_PRACTICES_EXPLOITED_FOR_INITIAL_ACCESS.PDF</a></li>
<li><a href="https://www.cisecurity.org/controls" target="_blank" rel="noopener noreferrer">https://www.cisecurity.org/controls</a></li>
</ul>
<h2> 学习资源</h2>
<h3> SentinelOne 推荐2022年要关注的22个安全类Twitter账号</h3>
<p>信息安全在于知识分享，在 Twitter 上你会发现我们这个行业最优秀最聪明的人就是这么做的。那么，在2022年，你应该跟随谁来关注时事，扩展你的知识，学习新的技能和资源呢？我们精心挑选了22个重要的网络安全账户，虽然你可以在我们前几年的<a href="https://www.google.com/search?q=site%3Ahttp%3A%2F%2Fsentinelone.com++twitter+accounts+following&amp;ie=UTF-8&amp;oe=UTF-8" target="_blank" rel="noopener noreferrer">Twitter名单</a>中找到一些推荐，但今年的名单上也有许多新的、有趣的、有影响力的推特用户。让我们来看看吧！</p>
<ul>
<li>名单
<ul>
<li><a href="https://twitter.com/KimZetter" target="_blank" rel="noopener noreferrer">@KimZetter</a></li>
<li><a href="https://twitter.com/maddiestone" target="_blank" rel="noopener noreferrer">@maddiestone</a></li>
<li><a href="https://twitter.com/cyb3rops" target="_blank" rel="noopener noreferrer">@cyb3rops</a></li>
<li><a href="https://twitter.com/campuscodi" target="_blank" rel="noopener noreferrer">@campuscodi</a></li>
<li><a href="https://twitter.com/cglyer" target="_blank" rel="noopener noreferrer">@cglyer</a></li>
<li><a href="https://twitter.com/billyleonard" target="_blank" rel="noopener noreferrer">@billyleonard</a></li>
<li><a href="https://twitter.com/Kostastsale" target="_blank" rel="noopener noreferrer">@Kostastsale</a></li>
<li><a href="https://twitter.com/vxunderground" target="_blank" rel="noopener noreferrer">@vxunderground</a></li>
<li><a href="https://twitter.com/likethecoins" target="_blank" rel="noopener noreferrer">@likethecoins</a></li>
<li><a href="https://twitter.com/RidT" target="_blank" rel="noopener noreferrer">@RidT</a></li>
<li><a href="https://twitter.com/theJoshMeister" target="_blank" rel="noopener noreferrer">@theJoshMeister</a></li>
<li><a href="https://twitter.com/ryanaraine" target="_blank" rel="noopener noreferrer">@ryanaraine</a></li>
<li><a href="https://twitter.com/craiu" target="_blank" rel="noopener noreferrer">@craiu</a></li>
<li><a href="https://twitter.com/AricToler" target="_blank" rel="noopener noreferrer">@AricToler</a></li>
<li><a href="https://twitter.com/evacide" target="_blank" rel="noopener noreferrer">@evacide</a></li>
<li><a href="https://twitter.com/4n6lady" target="_blank" rel="noopener noreferrer">@4n6lady</a></li>
<li><a href="https://twitter.com/zackwhittaker" target="_blank" rel="noopener noreferrer">@zackwhittaker</a></li>
<li><a href="https://twitter.com/trufae" target="_blank" rel="noopener noreferrer">@trufae</a></li>
<li><a href="https://twitter.com/Fox0x01" target="_blank" rel="noopener noreferrer">@Fox0x01</a></li>
<li><a href="https://twitter.com/HostileSpectrum" target="_blank" rel="noopener noreferrer">@HostileSpectrum</a></li>
<li><a href="https://twitter.com/GossiTheDog" target="_blank" rel="noopener noreferrer">@GossiTheDog</a></li>
<li><a href="https://twitter.com/juanandres_gs" target="_blank" rel="noopener noreferrer">@juanandres_gs</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>好好学习，天天向上；另外推荐两个可以Follow的Twitter List：Offense and Infosec Under 2.5k 。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://www.sentinelone.com/blog/22-cybersecurity-twitter-accounts-you-should-follow-in-2022/" target="_blank" rel="noopener noreferrer">https://www.sentinelone.com/blog/22-cybersecurity-twitter-accounts-you-should-follow-in-2022/</a></li>
</ul>
<h2> 安全事件</h2>
<h3> 中国互联网公司搜狐的员工被电子邮件欺诈欺骗，承诺给那些提供他们银行数据的人“津贴”</h3>
<p>中国互联网门户网站搜狐网周三表示，20多名员工在一起电子邮件诈骗案中损失超过4万元人民币(合6000美元) ，该诈骗案承诺向提供银行账户和其他个人身份信息的受益人提供“津贴”。</p>
<p>奇安信、中睿天下和微步在线等厂商均对这一件事件发布了分析报告，完整的攻击过程大致为：</p>
<ol>
<li>通过网络攻击手段获取到目标邮件服务器高级权限账号</li>
<li>以财务部、税务局、人力资源和社会保障服务平台及国家社会保险公共服务等部门名义下发的《关于发布2022最新补贴通知》邮件</li>
<li>该封邮件正文中放置了一张二维码图片，诱导收件人扫描正文中二维码。邮件附件的内容和邮件正文一样，并未携带病毒和可执行文件。（该组织利用 DGA 域名生成技术，生成了大量用于做为跳板的 DGA 域名，将其制成二维码。受害者通过手机扫描二维码来解析到对应的钓鱼页面）</li>
<li>通过快捷支付进行盗刷，购买虚拟商品进行分销变现</li>
</ol>
<blockquote>
<p>2021年12月，中国信通院发布的报告称，钓鱼邮件的发件者会模仿成信誉良好的组织或机构，其目标通常是窃取身份验证数据等敏感信息、安装恶意软件或获取信用卡号等其他财务资源。一部分钓鱼攻击属于鱼叉式网络钓鱼，具有高度针对性，但是无确定攻击对象的“广撒网”式钓鱼攻击活动更为普遍。未来较长一段时间内，网络钓鱼攻击将变得越来越常见，并可能和勒索软件、APT攻击等手段相结合，诱饵和所用邮箱也将和企业机构信息有更高的相关度。安全人员可适当开展网络安全培训、网络钓鱼模拟演练等工作，定期督促员工警惕钓鱼攻击的风险和危害，提升员工网络安全意识，防止被网络钓鱼。</p>
</blockquote>
<h4> 知识扩展</h4>
<ol>
<li>Google的这个防钓鱼测试挺有意思，用来做安全意识培训比干巴巴的文字体验好太多，<a href="https://phishingquiz.withgoogle.com/" target="_blank" rel="noopener noreferrer">https://phishingquiz.withgoogle.com</a></li>
<li>Microsoft的钓鱼模拟训练，<a href="https://docs.microsoft.com/zh-cn/microsoft-365/security/office-365-security/attack-simulation-training?view=o365-worldwide" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/zh-cn/microsoft-365/security/office-365-security/attack-simulation-training</a></li>
</ol>
<h4> 参考资料</h4>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qGbwJJ5oGn4tdnFadq0c8g" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/qGbwJJ5oGn4tdnFadq0c8g</a></li>
<li><a href="https://mp.weixin.qq.com/s/-WjOYPWIEGAUenLsQs7D7w" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/-WjOYPWIEGAUenLsQs7D7w</a></li>
<li><a href="https://mp.weixin.qq.com/s/uEiJIFzCqVuFsPzONu7v_A" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/uEiJIFzCqVuFsPzONu7v_A</a></li>
<li><a href="https://support.microsoft.com/zh-cn/windows/%E9%98%B2%E8%8C%83%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC-0c7ea947-ba98-3bd9-7184-430e1f860a44" target="_blank" rel="noopener noreferrer">https://support.microsoft.com/zh-cn/windows/防范网络钓鱼-0c7ea947-ba98-3bd9-7184-430e1f860a44</a></li>
</ul>
<h2> 行业报告</h2>
<h3> Verizon Business 发布了2022年数据泄露调查报告</h3>
<p>主要发现包括:</p>
<ol>
<li>勒索软件攻击事件同比增加了13% ，比过去5年的总和还要多</li>
<li>大约五分之四的违规行为可归因于有组织犯罪，外部行为者在一个组织中造成违规行为的可能性大约是内部行为者的4倍</li>
<li>在过去的一年中，82% 的数据泄露都与人为因素有关</li>
</ol>
<blockquote>
<p>正如Lapsus$靠买通内部人员拿下一家又一家的知名公司一样，人为因素一直是导致网络安全事件的主要原因，安全不光是技术对抗，更多的是人之间的对抗；而在现代企业的网络安全防御体系中，人也是最不受重视的环节，大家衷于采购最先进的网络安全技术和方案，并试图提高安全工具集成度和自动化水平，却在员工安全意识上投入不足。人员漏洞是最危险也最容易修复的漏洞（不需要昂贵的技术产品和顶尖技术人才），同时也是最难修复的漏洞（不被重视、缺乏预算）。
RSAC 2020的主题是：“人是安全要素”，RSAC在发布本次大会主题时宣称，网络安全不断发展，我们不断提出旨在阻止威胁的新策略和新方法。人工智能和机器学习等新技术比以往任何时候都更有效率地与不良行为者作战。高级恶意工具的日益普及、成本更低，使网络犯罪更加平民化。“人是安全的关键要素”这一基本认识似乎已被遗忘。但无论是安全防护还是攻击背后的恒久力量一直都是人。即便进入安全自动化时代，我们应对网络攻击的最宝贵的武器将永远是自己。因此，进入21世纪的第三个十年，RSAC2020成为提醒业界记起“人是安全要素”这一基本认识的好时机。
知名黑客Kevin Mitnick在15年前曾写道：人，而非技术，才是安全最弱的一环。在其畅销书《欺骗的艺术：控制安全中人的要素》，Kevin Mitnick证实了，即便没有高级的黑客技术，社工手段依然可以导致大规模数据泄露。</p>
</blockquote>
<h4> 参考资料</h4>
<ul>
<li><a href="https://www.verizon.com/business/resources/reports/2022/dbir/2022-data-breach-investigations-report-dbir.pdf" target="_blank" rel="noopener noreferrer">https://www.verizon.com/business/resources/reports/2022/dbir/2022-data-breach-investigations-report-dbir.pdf</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/dYd6gT.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>利用Calibre.recipe爬取文章</title>
      <link>https://mars.run/code/%E5%88%A9%E7%94%A8Calibre.recipe%E7%88%AC%E5%8F%96%E6%96%87%E7%AB%A0.html</link>
      <guid>https://mars.run/code/%E5%88%A9%E7%94%A8Calibre.recipe%E7%88%AC%E5%8F%96%E6%96%87%E7%AB%A0.html</guid>
      <source url="https://mars.run/rss.xml">利用Calibre.recipe爬取文章</source>
      <description>前言 多读书，读好书很重要，网上的有些精品资源只能在线一页一页翻着看，颇不方便，故研究了一下Calibre，用其强大的爬虫功能抓取这些文章，并自动生成带目录索引的电子书文件(mobi、epub)，以便在Kindle上随时阅读。 编写recipe脚本 Calibre&amp;nbsp;就不再介绍了，可以自行百度。 recipe 其实就是一段python代码，定义 calibre 的抓取行为，通过 Beautiful Soup 筛选出页面中要抓取的元素。相关文档参考： Beautiful Soup 4.2.0 DocumentationAPI Documentation for recipes</description>
      <category>代码学习</category>
      <pubDate>Wed, 18 Mar 2015 20:19:31 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>多读书，读好书很重要，网上的有些精品资源只能在线一页一页翻着看，颇不方便，故研究了一下Calibre，用其强大的爬虫功能抓取这些文章，并自动生成带目录索引的电子书文件(mobi、epub)，以便在Kindle上随时阅读。</p>
<h2> 编写recipe脚本</h2>
<p><code>Calibre</code>&nbsp;就不再介绍了，可以自行百度。</p>
<p>recipe 其实就是一段python代码，定义 calibre 的抓取行为，通过 Beautiful Soup 筛选出页面中要抓取的元素。相关文档参考：</p>
<blockquote>
<p>Beautiful Soup 4.2.0 DocumentationAPI Documentation for recipes</p>
</blockquote>
<p>简单来说，recipe 是一个固定的模板。找到要抓取的目录和每个目录项链接到相应内容页的正文的Dom元素即可。</p>
<p>下面以抓取《詩詞金庸》<a href="http://jinyong.ylib.com/works/v1.0/works/poem.htm" target="_blank" rel="noopener noreferrer">http://jinyong.ylib.com/works/v1.0/works/poem.htm</a>&nbsp;为例：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码保存为 <code>LouisChaPoem.recipe</code> 。整个代码比较简单明了，就不再赘述细节了。运行 <code>ebook-convert LouisChaPoem.recipe LouisChaPoem.epub</code>  就可以抓取了。（ebook-convert在calibre的安装目录下）</p>
<h2> 最后</h2>
<p>看看效果吧，正文：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/KmYDsZ.jpg" alt="KmYDsZ" tabindex="0" loading="lazy"><figcaption>KmYDsZ</figcaption></figure>
<p>最后推荐一些写好的Recipe：</p>
<blockquote>
<p><a href="https://github.com/ericzhang-cn/kindle-open-books" target="_blank" rel="noopener noreferrer">@ericzhang-cn</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/mine260309/calibre_recipes" target="_blank" rel="noopener noreferrer">@mine260309</a></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/KmYDsZ.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>机器学习实战之Kaggle_Titanic预测</title>
      <link>https://mars.run/code/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E4%B9%8BKaggle_Titanic%E9%A2%84%E6%B5%8B.html</link>
      <guid>https://mars.run/code/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E4%B9%8BKaggle_Titanic%E9%A2%84%E6%B5%8B.html</guid>
      <source url="https://mars.run/rss.xml">机器学习实战之Kaggle_Titanic预测</source>
      <description>介绍 如果你没有听过Kaggle，那你一定要来了解一下它： Kaggle 为全球顶尖数据科学家举办竞赛活动。那些有着科学难题的公司（比如 NASA）可以通过网络将数据和问题提交给 Kaggle，任何顶尖科学家都可以提交问题解决方案，网站会通过对每位科学家的贡献进行排名。到目前为止，在一场竞赛中至少有 30000 人提交至少一种模型。 简单来说就是一个数据科学竞赛网站，非常有趣。接下来让我们一起学习机器学习吧。 这次的任务是：Titanic-Kaggle</description>
      <category>代码学习</category>
      <pubDate>Tue, 23 Jun 2015 20:10:11 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 介绍</h2>
<p>如果你没有听过Kaggle，那你一定要来了解一下它：</p>
<blockquote>
<p>Kaggle 为全球顶尖数据科学家举办竞赛活动。那些有着科学难题的公司（比如 NASA）可以通过网络将数据和问题提交给 Kaggle，任何顶尖科学家都可以提交问题解决方案，网站会通过对每位科学家的贡献进行排名。到目前为止，在一场竞赛中至少有 30000 人提交至少一种模型。</p>
</blockquote>
<p>简单来说就是一个数据科学竞赛网站，非常有趣。接下来让我们一起学习机器学习吧。</p>
<p>这次的任务是：<a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener noreferrer">Titanic-Kaggle</a></p>
<p>我们的重点是学习机器学习的过程，所以这次不涉及具体的算法实现，而是使用第三方库来实现算法，这里推荐<a href="http://scikit-learn.org/stable/" target="_blank" rel="noopener noreferrer">scikit-learn</a>，它提供了许多工具和模型，使用起来非常方便。另外我们还是用了<a href="https://pandas.pydata.org/" target="_blank" rel="noopener noreferrer">Pandas</a>库(&nbsp;<code>pandas 是基于 Numpy 构建的含有更高级数据结构和工具的数据分析包</code>&nbsp;)来提高效率，还有<code>matplotlib</code>&nbsp;和&nbsp;<code>Seaborn</code>&nbsp;，通过图标直观的观察数据。</p>
<p>我们先写一段代码来看看原始数据吧。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>我们把training data 和 test data合并到了一起，因为在提取特征的时候，需要获取value的范围和分布。所以需要将他们合在一起处理。</li>
<li>Pandas合并data sets非常灵活，不会影响合并之前的原始数据，使用方便。</li>
</ul>
<p>输出如下，共有1309条数据，12个feature：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 数据预处理</h2>
<p>拿到数据第一步是观察一下数据，看看是否有缺失数据，分析一下相关特征等等。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到：</p>
<ol>
<li>Survived 的缺失可以忽略，因为<code>test.csv</code>中的数据本来就是没有Survived的。</li>
<li>Cabin 缺失很严重，我想可以忽略这一个特征了。</li>
<li>Age 缺失的并不多，而且Age是一个重要的特征，应该保留。</li>
</ol>
<p>再看看数据的内容吧：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先看看每个特征的含义：</p>
<ul>
<li>Age （年龄）</li>
<li>Cabin（客舱位置）</li>
<li>Embarked（港口编号）</li>
<li>Fare（票价）</li>
<li>Name（姓名）</li>
<li>Parch（父母/孩子的数量）</li>
<li>PassengerId</li>
<li>Pclass（客舱等级）</li>
<li>Sex（性别）</li>
<li>SibSp（配偶的数量）</li>
<li>Survived(存活与否)</li>
<li>Ticket（船票编号）</li>
</ul>
<p>直观的看，<code>PassengerId</code>，<code>Ticket</code>没什么用，先忽略他们。</p>
<h2> 处理缺失数据</h2>
<p>在数据中出现缺失或者错误的Value是很正常的事，一些预测模型可以很好的处理缺失数据&nbsp;<code>如神经网络(neural networks)</code>，有些则需要单独处理他们。我们使用随机森林(Random Forest)来做预测模型，它自身并不能对付缺失数据，所以需要单独进行处理。有两种方法：</p>
<ol>
<li>直接扔掉出现缺失Value的数据：只有少量的数据出现缺失Value的情况，这样做比较简单快捷。</li>
<li>给缺失的Value赋特殊值来表明它是缺失的：比较适用于分类变量，因为缺失Value就是不存在的数据，如果给他分配平均值之类的数值并没有什么意义。除非是某些潜在原因使某些缺失值会影响其与另外一个值的关联(correlation)。并且这种方法不适用于连续变量。不过对于二元变量(binary variables)，我们可以把他的缺失值赋为0，正常情况下True为1，False为-1。</li>
</ol>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol>
<li>给缺失的Value赋平均值：这种简单的做法很普遍，对于不重要的特征来说用这种方法足矣。还可以结合其他变量来算平均值。对于分类变量，使用最常见的值或许比平均值更好。</li>
</ol>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>使用机器学习算法/模型来预测缺失数据：感觉只有数据量很大的情况下这样做才有效。</li>
</ol>
<h2> 变量转换</h2>
<p>变量转换的目的是将数据转换为模型适用的格式，不同方法实现的随机森林(Random Forest)接受不同类型的数据，Scikit-learn要求数据都是数字型<code>numeric</code>，所以我们要将原始数据转换为数字型<code>numeric</code>。</p>
<p>所有的数据可以分为两类：1.定性(Quantitative)变量可以以某种方式排序，Age就是一个很好的列子。2.定量(Qualitative)变量描述了物体的某一（不能被数学表示的）方面，Embarked就是一个例子。</p>
<h3> 定性(Qualitative)转换</h3>
<ol>
<li>Dummy Variables：就是类别变量或者二元变量，当qualitative variable是一些频繁出现的几个独立变量时，Dummy Variables比较适合使用。我们以Embarked为例，Embarked只包含三个值<code>'S','C','Q'</code>，我们可以使用下面的代码将其转换为dummies:</li>
<li>Factorizing：dummy不好处理Cabin（船舱号）这种标称属性，因为他出现的变量比较多。所以Pandas有一个方法叫做<code>factorize()</code>，它可以创建一些数字，来表示类别变量，对每一个类别映射一个ID，这种映射最后只生成一个特征，不像dummy那样生成多个特征。 下面的代码是对Cabin进行Factorizing：</li>
</ol>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 定量(Quantitative)转换</h3>
<ol>
<li>
<p>Scaling Scaling可以将一个很大范围的数值映射到一个很小的范围(<code>通常是-1 - 1，或则是0 - 1</code>)，很多情况下我们需要将数值做Scaling使其范围大小一样，否则大范围数值特征将会由更高的权重。比如：Age的范围可能只是0-100，而income的范围可能是0-10000000，在某些对数组大小敏感的模型中会影响其结果。</p>
<p>下面的代码是对Age进行Scaling：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Binning inning通过观察“邻居”(即周围的值)来连续数据离散化。存储的值被分布到一些“桶”或箱中，就像直方图的bin将数据划分成几块一样。下面的代码对Fare进行Binning。</p>
</li>
</ol>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 特征提取</h2>
<p>特征提取很重要的一个方面是深入理解数据，并且能提取出新的特征来做预测。机器学习的核心就是模型选取和参数选择，特征提取可以说是重中之重。</p>
<p>一个特征提取的例子是，从电话号码中提取中国家、地区、城市的信息，或者是从GPS中提取中国家、地区、城市的信息。只要能描述一个事物的qualitative变量，都有可能从中挖掘出有用的特征，另外，时序等信息也是非常有用的。</p>
<p>泰坦尼克号的这些数据非常简单，我们并不需要对数据做太多的处理，我们下面只对name，cabin和ticket提取一些变量。</p>
<p>举两个例子吧：</p>
<ol>
<li>
<p>Name 姓名这个特征本身来说没有什么用，但是我们可以从中提取出一个特征，<code>称呼</code>。</p>
<p>称呼，或许不同社会地位的人抢到逃生船的概率不同？代码如下：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Cabin 客舱信息包含了甲板和房间号，不同甲板位置不同，逃生船数量不同，人群年龄分布不同等等。不同房间号离甲板距离不同，离逃生船距离不同，等等。所以从客舱中提取中<code>甲板</code>和<code>房间号</code>这两个特征很重要。代码如下：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 开始处理</h2>
<p>前面理论说了那么多，还是实战看看吧，我们要预处理每一个特征。</p>
<h3> 首先是Age（年龄）</h3>
<p>Age（年龄）有263个缺失项，就简单地用平均值来填充，并看看填充前后的直方图：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/e1BIid.jpg" alt="e1BIid" tabindex="0" loading="lazy"><figcaption>e1BIid</figcaption></figure>
<p>可以看到经过平均值填充后，数据分布并不是很好。试试随机选取<code>平均值加减标准差</code>范围的数来改进，使数据更接近真实情况。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到：</p>
<p>![[Pasted image 20230217002600.png]]</p>
<p>感觉这样好多了。</p>
<p>接着，我们需要从年龄中提取一个特征出来，即：孩子。不是说ladies and kids first么？</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/eHiKsz.jpg" alt="eHiKsz" tabindex="0" loading="lazy"><figcaption>eHiKsz</figcaption></figure>
<p>孩子只有132人，却有着57%的生存率！看来是否是孩子，这一特征很重要。（数据支持，kids first，后面到Sex分析一下是不是ladies first）</p>
<p><strong><strong>Cabin（客舱位置）</strong></strong> 可以忽略</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong><strong>Embarked（港口编号）</strong></strong></p>
<p>Embarked（港口编号）只有2个缺失项，直接用最常见的值填充它，然后用图表看看其与Survived的关系：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/ICrD6R.jpg" alt="ICrD6R" tabindex="0" loading="lazy"><figcaption>ICrD6R</figcaption></figure>
<p>分别是不同Embarked（港口编号）的百分比、不同Embarked（港口编号）生存的数量、不同Embarked（港口编号）的生存率。Embarked（港口编号）特征只有三种取值，且S占70%以上，所以Embarked（港口编号）这个特征应该不要？</p>
<h3> Fare（票价）</h3>
<p>Fare（票价）只有1个缺失项,直接用平均值填充：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>绘图看看Fare（票价）与Survived的关系：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到：</p>
<p><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/rwPHr3.jpg" alt="rwPHr3" loading="lazy">
<img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/nrJ4Up.jpg" alt="nrJ4Up" loading="lazy"></p>
<p>可以看出票价集中在10左右，幸存的人的票价平均在48。</p>
<h3> Pclass（客舱等级）</h3>
<p>Pclass（客舱等级）考虑做Dummy Variables处理，使其生成更多的特征。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/1h3Dsf.jpg" alt="1h3Dsf" tabindex="0" loading="lazy"><figcaption>1h3Dsf</figcaption></figure>
<p>得到Pclass与Survived的关系，可以看出Pclass为3的生存率很低，我们试试把它的Dummy Variables去掉：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Sex（性别）</h3>
<p>老规矩，首先看看Sex与Survived的关系：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/YC3mXf.jpg" alt="YC3mXf" tabindex="0" loading="lazy"><figcaption>YC3mXf</figcaption></figure>
<p>果然是Ladies First呀！将Sex用数字表示:</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在除去之前已经drop的<code>PassengerId</code>,<code>Ticket</code>,<code>Cabin</code>,只剩下<code>Name</code>,<code>Parch</code>和<code>SibSp</code>了。</p>
<h3> Name（姓名），Parch（父母/孩子的数量），SibSp（配偶的数量）</h3>
<p>我们需要从这里面提取中他们是否有家人在船上这一特征，因为有家人意味着逃生过程中会有家人的帮助，生存率可能更高。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到:</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/88czBr.jpg" alt="88czBr" tabindex="0" loading="lazy"><figcaption>88czBr</figcaption></figure>
<p>可以看到，有家人在船上的人有更高的生存率；特征就处理到这里吧。</p>
<h2> 训练</h2>
<p>机器学习的模型很多，用于分类有：</p>
<ol>
<li>回归算法：Logistic Regression、 Ordinary Least Square等等。</li>
<li>决策树: CART、ID3、Random Forest等等。</li>
<li>贝叶斯：Navie Bayesian、BBN等等。</li>
<li>基于实例的算法：KNN、LVQ等等。</li>
<li>组合模型、关联规则、神经网络、深度学习等等。</li>
</ol>
<p>模型太多都看晕了，这种场景下选什么模型合适？因为我也不是很懂，所以大家可以自己查一下相关资料。在这里我选择了Random Forest和GBDT来试试。</p>
<p><strong>Random Forest:</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>GBDT:</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成后在Kaggle提交，只有<code>0.74641</code>分。</p>
<h2> 调优</h2>
<p>再观察一下数据，看看还有那些特征可以用到，又去Google了一番，整理出三个新特征：称谓、家庭大小、姓。</p>
<p><strong>称谓:</strong> 不同的称谓意味着不同的社会地位、不同的社会地位的人对人生、事物的理解不同。并且不同的社会地位乘坐逃生舱的概率也不同？可能某一类人的生存概率更高？</p>
<p><strong>家庭大小:</strong> 一家七个人的逃生概率大还是一家两个人的逃生概率大呢？人多的家庭会不会更难逃生呢？</p>
<p><strong>姓:</strong> 其实姓这个特征是为了辅助家庭这个特征的，同一个姓是一个家庭的概率更大？</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之前的Age和Fare忘了做Scaling处理，也把它加上：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们看看目前这些特征的feature importance:</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/nwobWe.jpg" alt="nwobWe" tabindex="0" loading="lazy"><figcaption>nwobWe</figcaption></figure>
<p>我们可以把后两个不重要的特征删掉：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面是参数调优，Sklean提供了两种方法，GridSearch和RandomizedSearch。在这两种情况下，都可以指定每个参数的取值范围，创建一个字典。将参数字典提供给search方法，它就会执行模型所指定的值的组合。GridSearch会测试参数每一个可能的组合。 而RandomizedSearch需要指定有多少不同的组合要测试，然后随机选择并组合他们。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于我的机器太慢了，就忽略这一步了。</p>
<p>最后，我使用Random Forest, 加上参数max_depth=5 防止模型过拟合，并将n_estimators放到了30000，再次跑了提交Kaggle，这次得到了<code>0.8038</code>：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/l1DnAD.jpg" alt="Results" tabindex="0" loading="lazy"><figcaption>Results</figcaption></figure>
<h2> 验证：学习曲线</h2>
<p>最后我们用学习曲线(Learning Curves)验证一下该模型的准确率。</p>
<p>方法很简单，我们逐步增加training data，标出training score(模型是否overfit)和error rate(模型预测的结果是否正确)。即可。继续重复这个过程，选出200、300、400、500等等个数据作为training data，然后标出training score和error rate，得出一个曲线，即学习曲线(Learning Curves)。</p>
<p>下图是Professor Ng在coursea上<a href="https://www.coursera.org/course/ml" target="_blank" rel="noopener noreferrer">机器学习</a>课程的ppt截图，描述了四种基本的曲线形状：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/xs44iQ.jpg" alt="Learning Curves" tabindex="0" loading="lazy"><figcaption>Learning Curves</figcaption></figure>
<p>其中红线代表error rate，蓝线代表training score。</p>
<blockquote>
<p>1.左上角是最优情况，随着样本的增加，error rate和training score都降低。2.右上角是最差情况，模型几乎无法预测数据，重新调整参数吧。3.左下角是high variance的情况，模型不够稳定，不能很好的fit新数据。4.右下角是high bias的情况，模型无法预测出准确的结果。</p>
</blockquote>
<p>这里解释一下variance和bias的意思，引用<a href="http://orangeprince.info/" target="_blank" rel="noopener noreferrer">@Orangeprince</a>的形象解释：</p>
<blockquote>
<p>首先 Error = Bias + Variance，Error反映的是整个模型的准确度，Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度，Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。举一个例子，一次打靶实验，目标是为了打到10环，但是实际上只打到了7环，那么这里面的Error就是3。具体分析打到7环的原因，可能有两方面：一是瞄准出了问题，比如实际上射击瞄准的是9环而不是10环；二是枪本身的稳定性有问题，虽然瞄准的是9环，但是只打到了7环。那么在上面一次射击实验中，Bias就是1,反应的是模型期望与真实目标的差距，而在这次试验中，由于Variance所带来的误差就是2，即虽然瞄准的是9环，但由于本身模型缺乏稳定性，造成了实际结果与模型期望之间的差距。</p>
</blockquote>
<p>High variance，low bias意味着”overfitting”，模型过拟合导致不能很好的用于新数据。而High bias，low variance意味着”underfitting”，模型欠拟合导致不能很好从样本中学习，很难去预测新数据。Bias与Variance往往是不能兼得的。如果要降低模型的Bias，就一定程度上会提高模型的Variance，反之亦然。</p>
<p>例如，如果模型存在high variance，一个常见的解决方法是给他增加更多的特征。但是这样也会增加bias，这中间的平衡需要仔细考虑。后面的链接提供了一些解决这类问题的方法。</p>
<p>下面我们看看在scikit-learn中如何实现：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们得到：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/K5fsQU.jpg" alt="Learning Curves Result" tabindex="0" loading="lazy"><figcaption>Learning Curves Result</figcaption></figure>
<h2> 总结</h2>
<p>还有许多可以优化的地方，通过实战才能发现学习中不足的地方。</p>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/e1BIid.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>阅读学习工作流</title>
      <link>https://mars.run/km/%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E5%B7%A5%E4%BD%9C%E6%B5%81.html</link>
      <guid>https://mars.run/km/%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E5%B7%A5%E4%BD%9C%E6%B5%81.html</guid>
      <source url="https://mars.run/rss.xml">阅读学习工作流</source>
      <description>前言 大多数人会对自己的记忆力过分高估。这个幻觉来自每时每刻都有一些确实可以记得住的东西，而记不住的东西恰恰则因为没有被记住所以看上去“并不存在”。换言之，每时每刻都有“我记得住”的证据，而“我记不住”的证据基本上难觅其踪。这也就是为什么总有那么多人真诚地相信自己考试成绩差是因为“没发挥好”。 相信自己的记忆力比自己估计得差（甚至差很多）是一个去除这一幻觉的行之有效的方法，因为只有相信这个事实，才能够在倾听的时候有意识地为了真正记住而反复（认真）回顾。在一些重要场合（课堂、会议等），也会因此真诚地借助辅助工具（笔记、照片、录音等）来帮助记忆。很多人从小就对老师“一定要记笔记”的建议置若罔闻，准确地讲，这种行为并非出自对老师的忽视或者鄙视，而是出自对自己记忆力“幻觉”的信任。 ——《把时间当作朋友》</description>
      <category>知识管理</category>
      <pubDate>Mon, 08 Nov 2021 12:09:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<blockquote>
<p>大多数人会对自己的记忆力过分高估。这个幻觉来自每时每刻都有一些确实可以记得住的东西，而记不住的东西恰恰则因为没有被记住所以看上去“并不存在”。换言之，每时每刻都有“我记得住”的证据，而“我记不住”的证据基本上难觅其踪。这也就是为什么总有那么多人真诚地相信自己考试成绩差是因为“没发挥好”。
相信自己的记忆力比自己估计得差（甚至差很多）是一个去除这一幻觉的行之有效的方法，因为只有相信这个事实，才能够在倾听的时候有意识地为了真正记住而反复（认真）回顾。在一些重要场合（课堂、会议等），也会因此真诚地借助辅助工具（笔记、照片、录音等）来帮助记忆。很多人从小就对老师“一定要记笔记”的建议置若罔闻，准确地讲，这种行为并非出自对老师的忽视或者鄙视，而是出自对自己记忆力“幻觉”的信任。</p>
<p>——《把时间当作朋友》</p>
</blockquote>
<p>From <a href="https://github.com/xiaolai/time-as-a-friend/blob/master/Chapter6.md" target="_blank" rel="noopener noreferrer">time-as-a-friend/Chapter6.md at master · xiaolai/time-as-a-friend</a></p>
<p>每天我都会在碎片化的时间听到、看到、读到各种信息，而绝大部分内容却成为过眼烟云，唯一的收获便是让我产生学到了很多东西的幻觉。即使把这些信息存入笔记软件，也会陷入「收藏即学习」的陷阱，绝大部分知识收藏的内容收藏之后，再也没有打开。</p>
<blockquote>
<p>「收藏即学习」的陷阱可以尝试使用费曼学习法来破局，建立正向反馈机制，实现从收藏者到创作者的转变。</p>
</blockquote>
<p>为了解决前面提到的困境，我读了很多关于个人知识管理有关的书籍和文章，结合自己的需求，创建了自己的阅读学习工作流。</p>
<h2> 整体流程</h2>
<p>工作流包括三个模块：<strong>获取信息、阅读信息和整理输出</strong>，利用输入强化输出，输出倒逼输入，践行<a href="https://www.liaolijun.com/feynman-technique/" target="_blank" rel="noopener noreferrer">费曼学习法</a>，其中每个模块附上了我常用的工具，供参考。</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/TBhwNH.jpg" alt="Created by draw.io" tabindex="0" loading="lazy"><figcaption>Created by <a href="http://draw.io" target="_blank" rel="noopener noreferrer">draw.io</a></figcaption></figure>
<h3> 获取信息</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>获取周期</th>
<th>订阅工具</th>
<th>存储工具</th>
<th>推荐阅读</th>
</tr>
</thead>
<tbody>
<tr>
<td>RSS</td>
<td>每日</td>
<td>Feedly</td>
<td>Notion</td>
<td><a href="https://sspai.com/post/59501" target="_blank" rel="noopener noreferrer">不那么完美的 RSS 订阅方案 — feedly + RSSHub</a></td>
</tr>
<tr>
<td>Newsletter</td>
<td>每周</td>
<td>Matter</td>
<td>Notion</td>
<td><a href="https://sspai.com/post/68585" target="_blank" rel="noopener noreferrer">试用 iOS 上的阅读应用 Matter</a></td>
</tr>
<tr>
<td>Podcast</td>
<td>每周</td>
<td>Spotify</td>
<td>Siyuan</td>
<td><a href="https://epic-tv.com/events/blog/the-rise-of-podcasts-and-what-spotify-has-to-do-with-it/#:~:text=Spotify%20uses%20podcasting%20to%20help,series%20that%20ran%20throughout%202018." target="_blank" rel="noopener noreferrer">THE RISE OF PODCASTS AND WHAT SPOTIFY HAS TO DO WITH IT</a></td>
</tr>
<tr>
<td>书籍</td>
<td>每周</td>
<td>人肉</td>
<td>Siyuan</td>
<td><a href="https://zhuanlan.zhihu.com/p/399935581" target="_blank" rel="noopener noreferrer">“无离线不笔记”为什么我要选择思源笔记？</a></td>
</tr>
<tr>
<td>公众号</td>
<td>碎片时间</td>
<td>微信</td>
<td>简约, Notion</td>
<td><a href="/3f1e9e5c14b24df69aa9c3b3334381f1">建立强大的 Notion 数据库，从了解函数开始</a></td>
</tr>
<tr>
<td>Twitter</td>
<td>碎片时间</td>
<td>Twitter</td>
<td>简约, Notion</td>
<td>N/A</td>
</tr>
<tr>
<td>网页</td>
<td>碎片时间</td>
<td>Google</td>
<td>简约, Notion</td>
<td><a href="https://sspai.com/post/61996" target="_blank" rel="noopener noreferrer">阅读模式 + 标注系统 + 稍后读，简悦 2.0 想成为你的知识管理解决方案</a></td>
</tr>
<tr>
<td>灵机一动</td>
<td>碎片时间</td>
<td>Flomo</td>
<td>Flomo, Notion, Siyuan</td>
<td><a href="https://sspai.com/post/64009" target="_blank" rel="noopener noreferrer">flomo 浮墨笔记的背后，藏着什么样的理念</a></td>
</tr>
</tbody>
</table>
<p>在获取信息阶段，相关的数据源就不赘述了，重点讲讲几个工具：</p>
<ol>
<li>Feedly
主流的RSS订阅软件使用起来差别不大，选择自己顺手的就行。</li>
<li>Matter
可以使用Matter提供的邮箱来订阅Newsletter，在移动端用户体验还不错。</li>
<li>Spotify
为了听墙外的podcast节目，且大部分的podcast都会在Spotify分发。（Spotify国内可以正常使用）</li>
<li>Flomo
软件功能简单，输入摩擦很小，设计让人有动力开始记录，也非常钦佩创始人<a href="https://www.notion.so/Plidezus-ff9bdac2b40e4ad2be23192a8c43f5fd" target="_blank" rel="noopener noreferrer">少楠</a>。</li>
</ol>
<h3> 阅读和笔记</h3>
<p>在这个阶段，我以Siyuan (思源笔记)为核心，对各种信息进行阅读、学习、整理，采用<strong>Zettelkasten卡片盒笔记法</strong>（<a href="https://sspai.com/post/60802" target="_blank" rel="noopener noreferrer">可以参考这篇文章</a>）来对知识点进行卡片化和相互连接，在daily note中写自由写作（而无需关心笔记分类），结合双链的方式让笔记自然生长。</p>
<p>在阅读的过程中，批注是很自然的事，<strong>简悦</strong>的主打功能**”阅读模式 + 剪藏 + 标注“**很好的实现了这一点，真正提升了网页阅读的效能，可以说是生产力工具。</p>
<p>将<strong>简悦</strong>剪藏的网页+标注通过API自动导入<strong>Notion</strong>后，在写作/使用时，就能在<strong>Notion</strong>使用全局搜索，快速找到所需要的资料。（Pocket/Instapper还需要开通会员才能全文检索）</p>
<p>这个时候我使用的工具如下：</p>
<ol>
<li>
<p>Notion</p>
<p>核心优势是强大的Database功能，非常适合做数据的整理、统计和关联等功能，同时也支持页面分享和多人协作，本站其实就是Notion分享的Page；但数据存在云端，对数据安全有疑虑的同学不建议使用。</p>
</li>
<li>
<p>Siyuan (思源笔记)</p>
<p>双链笔记软件非常多，我也体验过近两年火爆的Roam research、Obsidian和Logseg之类的笔记软件，最终选择思源笔记的原因有两个：一、大纲+Block的写作方式更加自由。二、本地化社区支持，开发者<a href="https://github.com/88250" target="_blank" rel="noopener noreferrer">D</a>和<a href="https://github.com/Vanessa219" target="_blank" rel="noopener noreferrer">V</a>会经常答疑。三、数据本地存储更加安全，云端存储可端到端加密。</p>
</li>
<li>
<p>简悦</p>
<p>沉浸式阅读体验，强大的划词批注功能，还能打通其他生产力工具（如Notion）。</p>
</li>
</ol>
<h3> 整理输出</h3>
<p>我会使用Siyuan (思源笔记) 完成最终的输出过程，并将完成的文章整理到Notion，在Notion强大的Database功能加持下，在Notion做知识整理体验非常愉悦；可以体验下少楠的<a href="https://pmthinking.com" target="_blank" rel="noopener noreferrer">产品沉思录</a>。</p>
<h2> 最后</h2>
<p>引用工作流的祛魅：从工具、阅读到写作](<a href="https://sspai.com/post/71658" target="_blank" rel="noopener noreferrer">https://sspai.com/post/71658</a>)中写到的内容作为结尾：</p>
<p>第一，在工作流中，<strong>实践先行，理念优先于工具</strong>。不过，关于工作流纯理念性的论述力有不逮，整篇文章依然主要围绕工具和技术加以展开。另外，高效率的工作流设计和运行还会涉及<strong>注意力管理、时间管理或者精力管理</strong>等维度，这些内容也是需要加以进一步考虑的。</p>
<p>第二，<strong>可能会过于拔高工作流的重要性</strong>。如果使用场景比较单一，需要一个人集中精力完成单个简单项目的时候，那么先行动起来更好，不需要刻意在意工作流。如果处理工作流的精力成本超过了工作本身，那么先停止折腾工作流，在工作实践中你会逐步加深对于自己工作流的认知。</p>
<p>第三，一个合适的工作流对于个人和团队而言自然重要，然而同时也<strong>需要注意到工作流是一种中微观的战术策略。在工作流之外，也需要使用一些更为宏观的战略方案加以支撑</strong>。比如，个体需要及时更新思维方式，企业需要建立合适的组织架构。</p>
<p>第四，这条<strong>通往效率生活之路并没有止境</strong>，理想的效率与生活本身处于<strong>动态平衡</strong>之中。偶尔休息，回头看看甚至退几步也未尝不是好事。</p>
<p>共勉。</p>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/TBhwNH.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>WordPress 3.8.2 cookie伪造漏洞及Python使用urllib2出现30x跳转的问题</title>
      <link>https://mars.run/cybersecurity/WordPress%203.8.2%20cookie%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E%E5%8F%8APython%E4%BD%BF%E7%94%A8urllib2%E5%87%BA%E7%8E%B030x%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98.html</link>
      <guid>https://mars.run/cybersecurity/WordPress%203.8.2%20cookie%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E%E5%8F%8APython%E4%BD%BF%E7%94%A8urllib2%E5%87%BA%E7%8E%B030x%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98.html</guid>
      <source url="https://mars.run/rss.xml">WordPress 3.8.2 cookie伪造漏洞及Python使用urllib2出现30x跳转的问题</source>
      <description>背景 首先看这篇文章：WordPress 3.8.2 cookie伪造漏洞再分析 http://drops.wooyun.org/papers/1409 推荐阅读： The dangers of type coercion and remote management plugins</description>
      <category>网络安全</category>
      <pubDate>Sat, 10 May 2014 15:19:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>首先看这篇文章：WordPress 3.8.2 cookie伪造漏洞再分析 <a href="http://drops.wooyun.org/papers/1409" target="_blank" rel="noopener noreferrer">http://drops.wooyun.org/papers/1409</a></p>
<p>推荐阅读：</p>
<p><a href="http://joncave.co.uk/2013/03/dangers-of-type-coercion-and-remote-management/" target="_blank" rel="noopener noreferrer">The dangers of type coercion and remote management plugins</a></p>
<p>WordPress 3.8.2修复的一个重要漏洞是cookie伪造漏洞&nbsp;<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0166" target="_blank" rel="noopener noreferrer">(CVE-2014-0166)</a>。该漏洞可以被攻击者利用通过伪造身份验证Cookie，登陆网站。</p>
<h2> 利用</h2>
<p>具体的原理请看上面这篇文章，这里就不多重复了。</p>
<p>也就是说，我们只要把cookies设置成 “admin|$expiration|0”,就可以登陆后台了。</p>
<p>思路是：</p>
<ul>
<li>1.尝试$expiration构造Cookie</li>
<li>2.GET请求到<a href="http://www.example.com/wp-admin/profile.php" target="_blank" rel="noopener noreferrer">http://www.example.com/wp-admin/profile.php</a>,根据返回的http header判断是否跳转,如为200则成功</li>
<li>3.多线程,有条件使用多机器</li>
</ul>
<h2> 题外话</h2>
<p>在写利用脚本的时候发现，python的urllib2.urlopen会遇到301/302自动跳转的问题，这样无法判断出http状态码是否是302。来分析看看为什么吧。😃</p>
<p>打开urllib2源码，刚开头就看到了相关文档：</p>
<p><code>The HTTPRedirectHandler automatically deals with HTTP 301, 302, 303 and 307 redirect errors.</code></p>
<p>仔细阅读源码看一下调用过程：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里我想已经够清楚了(执行到了我们之前在文档看到的HTTPRedirectHandler)，最后的redirect_request：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以GET遇到状态码（301, 302, 303, 307）时会Request跳转到新的地址，所以我们无法获取这些状态码(没有保存下来)。</p>
<p>我们需要自己写一个hander来重写30x方法处理这种情况，保存状态码。代码如下：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，就可以正常返回301/302状态码。</p>
<p>另外，WordPress 3.8.2补丁分析 HMAC timing attack&nbsp;<a href="http://drops.wooyun.org/papers/1404" target="_blank" rel="noopener noreferrer">http://drops.wooyun.org/papers/1404</a>&nbsp;思路确实很赞。</p>
]]></content:encoded>
    </item>
    <item>
      <title>网络安全事件汇总</title>
      <link>https://mars.run/cybersecurity/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%B1%87%E6%80%BB.html</link>
      <guid>https://mars.run/cybersecurity/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%B1%87%E6%80%BB.html</guid>
      <source url="https://mars.run/rss.xml">网络安全事件汇总</source>
      <category>网络安全</category>
      <pubDate>Wed, 18 May 2022 00:00:10 GMT</pubDate>
      <content:encoded><![CDATA[<iframe class="airtable-embed" src="https://airtable.com/embed/shrcBBDiOqnxKuTlt?backgroundColor=blue&amp;viewControls=on" frameborder="0" onmousewheel="" width="100%" height="533" style="background: transparent; border: 1px solid #ccc;"></iframe>]]></content:encoded>
    </item>
    <item>
      <title>安全数据可视化</title>
      <link>https://mars.run/cybersecurity/%E5%AE%89%E5%85%A8%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.html</link>
      <guid>https://mars.run/cybersecurity/%E5%AE%89%E5%85%A8%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.html</guid>
      <source url="https://mars.run/rss.xml">安全数据可视化</source>
      <description>概述 数据可视化主要旨在借助于图形化手段，清晰有效地传达与沟通信息。随着大数据，机器学习，EDA的发展，数据可视化变得越来越重要。在大量的数据面前，传统方法也无能为力，使用可视化的方法可以快速直观地分析/展示数据。 为什么要可视化数据？ Discovery：用于探索、观察数据，将数据转换为知识。通过视觉展示，能够给人们一些新的观察视角，以便思考、发现这些数据所包含的知识。 Understanding：通过可视化，可能会发现一些传统统计学方法/数理知识无法发现的模式/规律/关联，使得研究人员更好地使用这些数据。 Informed decisions：快速、准确地将数据所包含的信息传递给读者，在损失一些细节的同时，在几秒钟的时间内将信息传递出去。</description>
      <category>网络安全</category>
      <pubDate>Sun, 19 Jun 2016 22:00:10 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>数据可视化主要旨在借助于图形化手段，清晰有效地传达与沟通信息。随着大数据，机器学习，EDA的发展，数据可视化变得越来越重要。在大量的数据面前，传统方法也无能为力，使用可视化的方法可以快速直观地分析/展示数据。</p>
<h2> 为什么要可视化数据？</h2>
<ol>
<li>Discovery：用于探索、观察数据，将数据转换为知识。通过视觉展示，能够给人们一些新的观察视角，以便思考、发现这些数据所包含的知识。</li>
<li>Understanding：通过可视化，可能会发现一些传统统计学方法/数理知识无法发现的模式/规律/关联，使得研究人员更好地使用这些数据。</li>
<li>Informed decisions：快速、准确地将数据所包含的信息传递给读者，在损失一些细节的同时，在几秒钟的时间内将信息传递出去。</li>
</ol>
<p>引用<a href="https://weibo.com/u/3181671860" target="_blank" rel="noopener noreferrer">宫一鸣</a>说的：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/QloZrX.jpg" alt="宫一鸣微博" tabindex="0" loading="lazy"><figcaption>宫一鸣微博</figcaption></figure>
<p>《Data-Driven Security: Analysis.Visualization and Dashboards》一书描述了通过了解人类视觉信息系统的运作，来帮助我们创造出优秀数据可视化：视觉信息通过眼睛，从光转化成电信号，这些信息经过<strong>视觉记忆(visual memory)<strong>的若干阶段，每个阶段都有特定的强度、限制以及功能。在我们能够意识到这些信息之前，大脑会快速地扫描视觉区域，这就是</strong>前注意处理(preattentive processing)</strong>。最后，大脑会让眼睛进行一系列的**扫视运动(saccadic movement)，**我们会聚焦在不同的特征上面，来帮助大脑建立视觉画面。</p>
<h3> 视觉记忆</h3>
<ul>
<li>图像记忆：视觉信息在这里进行十分短暂的停留。这是人们对视觉信息的第一印象，可以通过颜色、形状和其他线条来抓住观众的注意力以及传递一些数据的基本属性信息。</li>
<li>工作记忆：在这个阶段，根据任务和对象不同，大脑仅可以容纳三到五个对象，所以在展示数据的时候，应该限制每个视觉效果内部超过五个对象。</li>
<li>长期记忆：能够保持几天到几年的记忆，短期记忆是神经连接的暂时性强化，生理上的结构是反响回路（reverberatory circuit），而通过巩固后、可变为长期记忆。</li>
</ul>
<h3> 前注意处理</h3>
<p>平时我们在记笔记，画脑图的时候就不知不觉的运用了前注意处理的特点了，即画重点，分类标记等等。前注意处理可以很好地智能分组和聚集重要信息，通过强化部分视觉属性，可以轻松做的这一点，如：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/c4Eznn.jpg" alt="c4Eznn" tabindex="0" loading="lazy"><figcaption>c4Eznn</figcaption></figure>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/sphQ3z.jpg" alt="sphQ3z" tabindex="0" loading="lazy"><figcaption>sphQ3z</figcaption></figure>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/8F3g1w.jpg" alt="8F3g1w" tabindex="0" loading="lazy"><figcaption>8F3g1w</figcaption></figure>
<h2> <strong><strong>扫视运动</strong></strong></h2>
<p>人们在观察事物的时候，眼球会快速地各处移动，通过一系列的观察来建立整个图像。在我们观察一个可视化图像的时候也会这样，人的眼睛会注视在有明显特征的区域，然后在重要的点之间来回跳动，因此我们应该：</p>
<ul>
<li>不要在仪表盘上过多地展示视觉特征</li>
<li>赋予重要信息更明显的视觉特征</li>
<li>限制扫视运动耗费的时间</li>
</ul>
<h2> 可视化分析</h2>
<h3> 相关知识</h3>
<ul>
<li>统计学知识：很多数据都是数值型(numeric)的，因此均值、中值、方差、标准差、正态分布、蒙特·卡罗方法等等这些东西很有用。</li>
<li>可视化知识：美学及可视化方法的选择。</li>
<li>安全知识：识别误报、安全事件、安全事故等等。</li>
</ul>
<h3> 思考目标</h3>
<p>目标驱动而不是数据驱动。要清楚可视化这些数据的目标是什么，是分析数据找出规律/异常？还是直观的展示数据？还是其他用途？</p>
<h2> 数据预处理</h2>
<ul>
<li>数据清理：清洗脏数据</li>
<li>数据集成：将多文件或者多数据库中的异构数据进行合并，然后存放在一个一致的数据存储中。考虑以下几个问题： 1.模式匹配 2.数据冗余 3.数据值冲突</li>
<li>数据变换：1.平滑 2.聚集 3.数据概化 4.规范化：(1)最小-最大规范化 (2)零-均值规范化 (3)小数定标规范化 5.属性构造</li>
<li>数据规约：数据过大的情况下，使用数据归约技术获得比原始数据小的多的，但不破坏数据完整性的数据集，该数据集可以得到与原始数据相同的结果</li>
</ul>
<p>通过可视化手段，我们可以：</p>
<ol>
<li>综合信息，从海量、动态、模糊、矛盾的数据中获取深入的了解。</li>
<li>从可视化中得出意想不到的结论、证实猜想。</li>
<li>实时地将数据转换为有用的知识。</li>
</ol>
<p>可视化在数据挖掘中也非常重要，他是连接从数据升华到知识这个过程的桥梁，快速直观地发现数据中存在的规则，特性，走势等等，辅助数据分析及建模过程。前面的<a href="http://mars.run/2015/11/Machine%20learning%20kaggle%20titanic-0.8/" target="_blank" rel="noopener noreferrer">机器学习实战之Kaggle_Titanic预测</a>就大量使用了可视化技术来辅助分析。</p>
<p>下图是可视化分析概览：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/dUD5Sp.jpg" alt="概览" tabindex="0" loading="lazy"><figcaption>概览</figcaption></figure>
<h2> 常见应用</h2>
<table>
<thead>
<tr>
<th>分析</th>
<th>数据名称</th>
<th>数据源示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>流量监控</td>
<td>网络数据包日志</td>
<td>Tcpdump,Wireshark</td>
</tr>
<tr>
<td></td>
<td>网络数据包日志</td>
<td>CiscoNetFlow</td>
</tr>
<tr>
<td>状态监控</td>
<td>状态监控日志</td>
<td>BigBrother,vSphere</td>
</tr>
<tr>
<td>事件监控</td>
<td>IDS/IPS日志</td>
<td>Snort，Bro</td>
</tr>
<tr>
<td></td>
<td>防火墙日志</td>
<td>Cisco，Checkpoint</td>
</tr>
<tr>
<td></td>
<td>网络应用操作日志</td>
<td>Apache，Nginx，Exchange，DNS</td>
</tr>
<tr>
<td></td>
<td>漏洞扫描与监控日志</td>
<td>Fortify，Nessus，Zabbix</td>
</tr>
<tr>
<td>其他日志</td>
<td>数据库日志，系统日志等等</td>
<td></td>
</tr>
</tbody>
</table>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/tfEAXK.jpg" alt="常见应用" tabindex="0" loading="lazy"><figcaption>常见应用</figcaption></figure>
<h2> 参考资料</h2>
<ol>
<li><a href="http://www.cqvip.com/read/read.aspx?id=27784761" target="_blank" rel="noopener noreferrer">网络安全可视化研究综述</a></li>
<li><a href="https://item.jd.com/11771405.html" target="_blank" rel="noopener noreferrer">数据驱动安全：数据安全分析、可视化和仪表盘</a></li>
<li><a href="https://www.perceptualedge.com/blog/?p=1897" target="_blank" rel="noopener noreferrer">Visual Business Intelligence</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/QloZrX.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>N-gram在安全领域的应用</title>
      <link>https://mars.run/cybersecurity/N-gram%E5%9C%A8%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8.html</link>
      <guid>https://mars.run/cybersecurity/N-gram%E5%9C%A8%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8.html</guid>
      <source url="https://mars.run/rss.xml">N-gram在安全领域的应用</source>
      <description>什么是N-Gram？ N-Gram是一种在自然语言处理(NLP)中常用的一种概率语言模型(Probabilistic Language Model)，常用于语音\手写识别、机器翻译、拼写纠错等等领域。 它的本质就是计算一个句子或者一连串词出现的概率。 /* T 是由 W1,W2,W3,W4,W5 ... Wn组成的一个句子。 */ P(T) = P(W1,W2,W3,W4,W5 ... Wn) //这个句子出现的概率是里面每一个词出现的概率的叠加。 P(W5|W1,W2,W3,W4) //已经出现第1个至第4个的词的情况下，第5个词出现的概率。</description>
      <category>网络安全</category>
      <pubDate>Sun, 19 Jun 2016 22:00:10 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是N-Gram？</h2>
<p>N-Gram是一种在自然语言处理(NLP)中常用的一种概率语言模型(Probabilistic Language Model)，常用于语音\手写识别、机器翻译、拼写纠错等等领域。</p>
<p>它的本质就是计算一个句子或者一连串词出现的概率。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/r9iFeU.jpg" alt="Google" tabindex="0" loading="lazy"><figcaption>Google</figcaption></figure>
<p>I am working 后面很有可能出现<code>at</code>,&nbsp;<code>in</code>,&nbsp;<code>for</code>&nbsp;，而不是<code>refrigerator</code>,&nbsp;<code>throw</code>,&nbsp;<code>gull</code>。那么如何计算N-Grams呢？我们可以使用链式法则(<a href="https://en.wikipedia.org/wiki/Chain_rule_(probability)" target="_blank" rel="noopener noreferrer">Chain Rule</a>)，求多个关联事件并存时的概率：</p>
<ul>
<li>2个事件同时发生的概率：<strong>P(a, b) = P(a | b) * P(b)</strong></li>
<li>3个事件的概率链式调用：<strong>P(a, b, c) = P(a | b, c) * P(b, c) = P(a | b, c) * P(b | c) * P(c)</strong></li>
<li>推广到N个事件，概率链式法则为：<strong>P(X1, X2, ... Xn) = P(X1 | X2, X3 ... Xn) * P(X2 | X3, X4 ... Xn) ... P(Xn-1 | Xn) * P(Xn)</strong></li>
</ul>
<p>但是这样会有两个问题：</p>
<ol>
<li>参数空间过大，不可能实用化。（N越大越难计算）</li>
<li>数据稀疏严重，语言有各种各样的组合，数据量太大，无法获取这么全的数据。</li>
</ol>
<p>所以为了简化这个问题，我们引入马尔科夫假设（Markov Assumption）：”一个词的出现仅仅依赖于它前面出现的一个或者有限的几个词。”</p>
<ol>
<li>如果一个词的出现仅仅依赖于它本身，我们称之为 Uni-gram model :&nbsp;<code>P(T) = P(W1)P(W2)...P(Wn)</code></li>
<li>如果一个词的出现仅仅依赖于它前面出现的一个词，我们称之为 Bi-gram model :&nbsp;<code>P(T) = P(W1)P(W2|W1)P(W3|W2)...P(Wn|Wn-1)</code></li>
<li>如果一个词的出现仅仅依赖于它前面出现的两个词，我们称之为 Tri-gram model :&nbsp;<code>P(T) = P(W1)P(W3|W1,W2)...P(Wn|Wn-2,Wn-1)</code></li>
<li>依次类推到仅依赖于它前面出现的N个词，还有4-gram, 5-gram。</li>
</ol>
<p>下面用Bi-gram举个例子，语料库来自&nbsp;<a href="http://www1.icsi.berkeley.edu/Speech/berp.html" target="_blank" rel="noopener noreferrer">[Berkeley Restaurant Project]</a>&nbsp;，总词数为 10132。</p>
<p>词和词频率：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>want</th>
<th>to</th>
<th>eat</th>
<th>chinese</th>
<th>food</th>
<th>lunch</th>
<th>spend</th>
</tr>
</thead>
<tbody>
<tr>
<td>2533</td>
<td>927</td>
<td>2417</td>
<td>746</td>
<td>158</td>
<td>1093</td>
<td>341</td>
<td>278</td>
</tr>
</tbody>
</table>
<p>词序列频率：</p>
<table>
<thead>
<tr>
<th>*</th>
<th>i</th>
<th>want</th>
<th>to</th>
<th>eat</th>
<th>chinese</th>
<th>food</th>
<th>lunch</th>
<th>spend</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>5</td>
<td>827</td>
<td>0</td>
<td>9</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>want</td>
<td>2</td>
<td>0</td>
<td>608</td>
<td>1</td>
<td>6</td>
<td>6</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>to</td>
<td>2</td>
<td>0</td>
<td>4</td>
<td>686</td>
<td>2</td>
<td>0</td>
<td>6</td>
<td>211</td>
</tr>
<tr>
<td>eat</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>16</td>
<td>2</td>
<td>42</td>
<td>0</td>
</tr>
<tr>
<td>chinese</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>82</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>food</td>
<td>15</td>
<td>0</td>
<td>15</td>
<td>0</td>
<td>1</td>
<td>4</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>lunch</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>spend</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>9</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>根据上表我们可以直观的看出，在这八个词的组合中，概率最高的句子是： i want to eat lunch 。它的概率是 P(i want to eat lunch) = P(i)P(want|i)P(to|want)P(eat|to)P(lunch|eat) = 2533/10132&nbsp;* <em>827/2533</em>&nbsp;* 608/927&nbsp;* <em>686/2417</em>&nbsp;* 42/746 = 0.25&nbsp;* <em>0.326</em>&nbsp;* 0.656&nbsp;* <em>0.284</em>&nbsp;* 0.056 = 0.00085</p>
<h3> Smoothing</h3>
<p>随着N-Grams的N的增大，N-Grams的数量对越来越多。如果词表中有10000个词，Bi-Gram模型可能产生100000000个N-Gram，Tri-Gram模型则可能产生1000000000000个N-Gram，那么会出现(unseen events)，词库中的某些词在训练样本中没有的情况（比如<code>in</code>在训练样本中没有出现在<code>turn</code>
后面）。为了避免在这种情况下概率为0，我们使用Smoothing来解决。</p>
<ol>
<li>
<p>add-1 smoothing : 很简单，给所有统计的counts加 1 。</p>
</li>
<li>
<p>add-k smoothing : 将高概率分到unseen events，在计算概率的时候，选择一个合适的k值。</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/MEKSo5.jpg" alt="add-k" tabindex="0" loading="lazy"><figcaption>add-k</figcaption></figure>
</li>
<li>
<p>backoff ： 如果Tri-gram统计为0，就去看Bi-gram，以此类推。</p>
</li>
<li>
<p>interpolation : 以权重，将Tri-gram，Bi-gram，Uni-gram综合起来。（举例）</p>
</li>
<li>
<p>kneser-ney smoothing : 以地位向高位，或者高位向地位的方向，传递高频。</p>
</li>
</ol>
<h2> 使用Python生成N-grams</h2>
<p>简单的实现：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> NIDS中的应用</h2>
<h3> 案例一</h3>
<p>Ke Wang 和 Salvatore J. Stolfo 在《Anomalous Payload-based Network Intrusion Detection 》中提出了一种基于1-Gram的方法，将数据包以端口分类，相同端口的数据包再以不同的长度分类，然后计算出ASCII字符0-255的平均分布频率，作为一个特征，加上平均分布频率的平均值，方差，标准差作为另一个特征。有了这两个特征，就可以在异常检测中建立模型，完成任务。如下图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/qvrUtF.jpg" alt="案例一" tabindex="0" loading="lazy"><figcaption>案例一</figcaption></figure>
<p>整个思路是：是训练阶段，算出不同端口/长度数据包的平均字节概率分布模型(平均值，方差，标准差)，预测阶段，算出新数据包的字节概率分布模型，使用马氏距离(Mahalanobis distance)，比较两个模型的差异，当差异超过某个阈值的时候，则检测出异常。还加上了增量学习(Incremental learning)使整个模型随着新数据的到来，不断的更新自己的参数(平均值，方差，标准差)，”淘汰”旧数据，”更新”新数据。</p>
<p>文中还提到了一种实现签名检测的方法：将字节的平均概率分布图，把频率从高到低进行重排序。这样得出的分布图很像Zipf-like分布(指数函数/幂函数少数值频繁出现，多数值偶尔出现。通俗地讲，就是二八原则：80%的财富集中在20%的人手中……80%的用户只使用20%的功能……20%的用户贡献了80%的访问量……)，这样用很小的长度就表示了整个ASCII范围的平均概率分布。比如下图，重排序后只用83个unique 的字符就表示了整个平均概率分布。</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/frPmAf.jpg" alt="案例一" tabindex="0" loading="lazy"><figcaption>案例一</figcaption></figure>
<p>通过这种方法将已识别/确认的异常数据包做成签名(signature)，可以快速准确地检测其他地方可能出现的相同异常数据包。</p>
<h3> 案例二</h3>
<p>前面说到的方法是1-Gram的应用，然而1-Gram的简单性(平均字节概率分布)很容易受到拟态攻击(mimicry attacks)，攻击者可以通过填充无用字符的方法来伪造出正常的概率分布，从而绕过检测。于是他们又提出了基于N-gram N大于1 的方法。见《Anagram: A Content Anomaly Detector Resistant to Mimicry Attack》</p>
<p>N-gram的本质和1-Gram是一样的，只不过特征空间变大大，在计算的时间/内存开销也很大。比如一个TCP 数据包，长度是256，那么他的N-garm就有256^n。作者通过选取几个N值，比如3-Gram, 4-Gram, 5-Gram等等，然后用Bloom filter(原理相当于哈希表)进行存储。最后在ROC曲线中比较这些N-gram的召回率与准确率，选取合适的模型。如图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/JsmuVT.jpg" alt="案例二" tabindex="0" loading="lazy"><figcaption>案例二</figcaption></figure>
<p>其他细节就略过，感兴趣可以自己查阅。</p>
<h2> 其他应用</h2>
<p>N-gram在安全领域还有很多其他的应用，比如HIDS(通过系统调用做异常检测)、恶意软件分类/识别、敏感词识别/屏蔽等等。但是效果却不好，误报、漏报严重。原因之前也提过，比如：测试还在用DARPA1999, KDD99等老样本、模型存在偏差样本性、缺乏实践等等问题。</p>
<p>开源项目参考：</p>
<p><a href="https://github.com/chwress/salad" target="_blank" rel="noopener noreferrer">https://github.com/chwress/salad</a></p>
<h2> 参考资料</h2>
<ol>
<li><a href="http://academiccommons.columbia.edu/catalog/ac%3A125704" target="_blank" rel="noopener noreferrer">Anomalous Payload-based Network Intrusion Detection</a></li>
<li><a href="http://ids.cs.columbia.edu/sites/default/files/anagram-camera-fixed.pdf" target="_blank" rel="noopener noreferrer">Anagram: A Content Anomaly Detector Resistant to Mimicry Attack</a></li>
<li><a href="https://lagunita.stanford.edu/c4x/Engineering/CS-224N/asset/slp4.pdf" target="_blank" rel="noopener noreferrer">N-Grams tutorial</a></li>
<li><a href="https://en.wikipedia.org/wiki/N-gram" target="_blank" rel="noopener noreferrer">N-Grams wikipedia</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/r9iFeU.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>入侵检测系统如何降低误报率？</title>
      <link>https://mars.run/cybersecurity/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E8%AF%AF%E6%8A%A5%E7%8E%87%EF%BC%9F.html</link>
      <guid>https://mars.run/cybersecurity/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E8%AF%AF%E6%8A%A5%E7%8E%87%EF%BC%9F.html</guid>
      <source url="https://mars.run/rss.xml">入侵检测系统如何降低误报率？</source>
      <description>背景 入侵检测技术一般分为异常检测和特征/签名检测，这里主要讨论的是网络入侵检测系统(NIDS)。 异常检测 (Anomaly detection)：假设入侵者活动异常于正常主体的活动。常用的方法有：关联规则、神经网络、SVM、邻近算法、隐含马尔可夫模型、Kalman过滤器、聚类算法、PCA、信息论等等。缺点是：需要训练样本、误报率（异常行为≠入侵行为）高。 特征/签名检测 (Misuse/Signature detection)：假设入侵者活动可以用一种模式来表示，然后将观察对象与之进行比较，判别是否符合这些模式。常用的方法有：关联规则、神经网络、SVM、决策树、遗传算法、贝叶斯网络等等。缺点是：对新的入侵方法无能为力。</description>
      <category>网络安全</category>
      <pubDate>Wed, 06 Apr 2016 18:05:13 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>入侵检测技术一般分为异常检测和特征/签名检测，这里主要讨论的是网络入侵检测系统(NIDS)。</p>
<ol>
<li>异常检测 (Anomaly detection)：假设入侵者活动异常于正常主体的活动。常用的方法有：关联规则、神经网络、SVM、邻近算法、隐含马尔可夫模型、Kalman过滤器、聚类算法、PCA、信息论等等。缺点是：需要训练样本、误报率（异常行为≠入侵行为）高。</li>
<li>特征/签名检测 (Misuse/Signature detection)：假设入侵者活动可以用一种模式来表示，然后将观察对象与之进行比较，判别是否符合这些模式。常用的方法有：关联规则、神经网络、SVM、决策树、遗传算法、贝叶斯网络等等。缺点是：对新的入侵方法无能为力。</li>
</ol>
<p>主流的入侵检测系统通常是采用异常检测+特征/签名检测。他们都存在的问题就是：</p>
<ol>
<li>告警的基数大，即使只有1%的误报率，也会产生大量的误报告警。</li>
<li>误报率往往跟漏报率成反比，改进算法降低误报率可能会增加漏报率，降低系统的可靠性。</li>
<li>大量的告警需要人工审核，造成疲惫和不信任感。</li>
</ol>
<h2> 基于输出数据(Outgoing data)</h2>
<p>完整的数据流应该包括输入和输出两个部分，而大部分NIDS却只考虑了输入数据，没有使用输出数据。通常情况下，存在异常/恶意输入数据，并不意味着有成功的入侵行为。比如一个任意文件读取的HTTP请求，只有当它的响应体中包含那个文件的内容，才算是一个成功的入侵行为。所以降低误报率的一个方法就是对输入和输出数据进行关联分析。而输出的异常检测，就是另一种方法。</p>
<p>输出数据有以下几个问题：</p>
<ol>
<li>不同程序/服务的输出数据不同，而且在使用的过程中，输出数据可能会一直变化。</li>
<li>不同程序/服务对于一种攻击类型做出的反应不同（比如一个SQL注入的HTTP请求，有些程序直接阻断，有些程序做了过滤，正常返回）。</li>
<li>如何把输入和输出数据关联起来？</li>
</ol>
<p>那么这种降低误报的方法就是在传统的基于输入的NIDS的基础上，增加：1、输入输出数据的关联分析。2、输出数据的异常检测。结构如下：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/HAObFW.jpg" alt="结构" tabindex="0" loading="lazy"><figcaption>结构</figcaption></figure>
<p><code>一次成功的攻击行为一定会引起程序/服务的异常输出(输出数据、响应时间、其他行为等等)</code>。当NIDS触发告警，关联引擎查看该告警对应的输出数据是否有异常，如果存在异常才认定为True positive。也可将攻击行为分类，关联分析输出数据是否符合该攻击行为的响应。当然，这也存在着许多缺点：1、每个程序/服务第一需要大量的样本训练。2、程序/服务的某些特征出现变动，需要重新训练样本。3、输出数据太多(比如我司http下行流量4GB/s)，收集、训练成本太高。4、其他…</p>
<h2> 基于威胁模型(Thread Model)</h2>
<p>NIDS的目的就是随时发现可能的入侵行为，并进行具体分析，及时、主动地进行干预(发送告警)，从而取得防患于未然的效果，也就是说降低风险。在风险管理中，<code>Risk = (probablity of the accident occuring) x (expected loss in case of accident)</code>。其中(expected loss in case of accident)可以理解的攻击的类型，常见的有三类：</p>
<ol>
<li>信息收集类（域名/IP/服务/端口扫描、漏洞扫描器等）</li>
<li>拒绝服务类（带宽、资源消耗）</li>
<li>程序/服务攻击（获取权限、数据库、Shell等等）</li>
</ol>
<p>其中第三种类型的攻击造成的损失最大，而第一种类型的攻击并不会立马带来什么损失，所以针对不同类型的攻击，应当给予不同的分数（每种类型的攻击还可以细分）。同时，(probablity of the accident occuring)可以理解为攻击发生的概率，那么同一输入数据/类型攻击的告警数量越多是不是意味着攻击发生的概率大呢？结合这两点因素，组成一个评分系统，再评估出一个合理的阈值，认为所有小于阈值的告警都是误报。</p>
<h2> 改进算法/训练样本/模型</h2>
<p>这一块任重而道远（比如：测试还在用DARPA1999, KDD99等样本、模型存在偏差样本性、缺乏实践等等问题），在此就不细谈了，下图是相关的研究：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/en0vmf.jpg" alt="相关研究" tabindex="0" loading="lazy"><figcaption>相关研究</figcaption></figure>
<h2> 参考资料</h2>
<ol>
<li>Damiano Bolzoni, Sandro Etalle. APHRODITE: an Anomaly-based Architecture for False Positive Reduction</li>
<li><a href="https://www.symantec.com/connect/articles/strategies-reduce-false-positives-and-false-negatives-nids" target="_blank" rel="noopener noreferrer">http://www.symantec.com/connect/articles/strategies-reduce-false-positives-and-false-negatives-nids</a></li>
<li>Asieh Mokarian, Ahmad Faraahi, Arash Ghorbannia Delavar. False Positives Reduction Techniques in Intrusion Detection Systems-A Review</li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/HAObFW.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Joomla 3.4.7 修复的反序列化与SQL注入</title>
      <link>https://mars.run/cybersecurity/Joomla%203.4.7%20%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8ESQL%E6%B3%A8%E5%85%A5.html</link>
      <guid>https://mars.run/cybersecurity/Joomla%203.4.7%20%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8ESQL%E6%B3%A8%E5%85%A5.html</guid>
      <source url="https://mars.run/rss.xml">Joomla 3.4.7 修复的反序列化与SQL注入</source>
      <description>反序列化漏洞修复分析 前一阵子 Joomla 的对象注入很火，而官方3.4.6的修复仅仅是严格过滤了X_FORWARDED_FOR、注释了USER_AGENT存入SESSION那一句，见这里,这样只是指哪补哪，治标不治本。看来官方上次的修复只是临时解决方案，这次的更新(3.4.7)算是彻底解决了此问题。</description>
      <category>网络安全</category>
      <pubDate>Tue, 20 Oct 2015 08:08:11 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 反序列化漏洞修复分析</h2>
<p>前一阵子 Joomla 的对象注入很火，而官方3.4.6的修复仅仅是严格过滤了X_FORWARDED_FOR、注释了USER_AGENT存入SESSION那一句，见<a href="https://github.com/joomla/joomla-cms/commit/995db72ff4eaa544e38b4da3630b7a1ac0146264#diff-aba80b5850bf0435954b29dece250cbfL1021" target="_blank" rel="noopener noreferrer">这里</a>,这样只是指哪补哪，治标不治本。看来官方上次的修复只是临时解决方案，这次的更新(3.4.7)算是彻底解决了此问题。</p>
<p>上次的对象注入，需要满足三个条件：</p>
<ol>
<li>自己实现session的处理方式，重新实现了 session 存储的read()和write()方法，但是并没有对 session 的值进行安全处理。</li>
<li>Mysql非strict mode下，使用utf8mb4字符&nbsp;<code>\xF0\x9D\x8C\x86</code>&nbsp;来截断。</li>
<li>PHP &lt;= 5.6.13 session中反序列化解析的BUG。</li>
</ol>
<p>Joomla 官方也只能解决第一个，也就是改进session的处理方式。这次更新，在 libraries/cms/version/version.php 中，将SESSION存储在内部的Registry类对象中，弃用了以前使用 $_SESSION[$namespace][$name] 的方式：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>并且，在写SESSION的时候会先做base64_encode：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，$_SESSION 就只剩下了$_SESSION[‘joomla’]，而且$_SESSION[‘joomla’] 只存储了Registry的对象$data，在执行read()和write()时候，SESSION是经过base64_encode后的数据，就不会存在read()之后自动反序列化而导致对象注入了。</p>
<p>在反序列化的时候也不存在unserialize参数可控的情况。（可控的只是$data的成员变量）</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Joomla官方这次的解决方案比较好，不像上次那样治标不治本，这样的态度值得称赞。反观Apache对struts2 漏洞的修复…就不说了。</p>
<h2> SQL注入漏洞分析</h2>
<h3> 漏洞分析</h3>
<p>代码位于，administrator/components/com_categories/models/category.php，save()函数内：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 $associations 未经过适当处理、我们跟着流程来看看。</p>
<p>首先，<code>$assoc = $this-&gt;getAssoc();</code>&nbsp;为 True 的时候整个逻辑才能进来，这个<code>getAssoc()</code>是什么呢？跟进getAssoc()的实现(文件的 1234 行)，发现关键是在：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>搜索一下，发现 JLanguageAssociations 是 Joomla 的一个多语言插件&nbsp;<a href="http://www.slideshare.net/erictiggeler/creating-a-multilingual-site-in-joomla-joomla-3-beginners-guide-eric-tiggeler" target="_blank" rel="noopener noreferrer">http://www.slideshare.net/erictiggeler/creating-a-multilingual-site-in-joomla-joomla-3-beginners-guide-eric-tiggeler</a>, 这个插件是 Joomla 自带的，默认没有开启，我们在后台将他开启。</p>
<p>然后，继续看代码，<code>$associations = $data['associations'];</code>, $data是post过来的数据，$associations没有经过过滤就传到了：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>导致SQL注入。</p>
<p>那 Joomla 有没有全局过滤呢？我们看看 Joomla 是如何处理POST数据的。</p>
<p>在 libraries/legacy/controller/form.php , save() 函数，</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>validate() 函数在 libraries/legacy/model/form.php 302行, 他又调用了libraries/joomla/form/form.php 的filter() 函数，具体实现就不继续了，总之这里的POST参数只是处理了 ‘ XSS and specified bad code. ‘。</p>
<p>最后，构造POC。在修改分类，保存的时候，修改POST数据:</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jform[associations][en-GB] 这个参数就是 $associations，成功注入。</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/dWuY7g.jpg" alt="Jommla" tabindex="0" loading="lazy"><figcaption>Jommla</figcaption></figure>
<blockquote>
<p>这里打一波广告，我们的Skywolf是可以轻松检测出来的，如下图</p>
</blockquote>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/vwJyVt.jpg" alt="Skywolf" tabindex="0" loading="lazy"><figcaption>Skywolf</figcaption></figure>
<p>另外，<code>libraries/legacy/model/admin.php</code> 这里也存在着同样的问题。</p>
<h3> 修复方案</h3>
<p>官方增加了：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将 $associations 中的所有值转换为int型。还有将 $id 强制转换为int。</p>
<h2> 参考资料</h2>
<ol>
<li><a href="http://drops.wooyun.org/papers/11330" target="_blank" rel="noopener noreferrer">http://drops.wooyun.org/papers/11330</a></li>
<li><a href="http://drops.wooyun.org/papers/11371" target="_blank" rel="noopener noreferrer">http://drops.wooyun.org/papers/11371</a></li>
<li><a href="http://bobao.360.cn/learning/detail/2501.html" target="_blank" rel="noopener noreferrer">http://bobao.360.cn/learning/detail/2501.html</a></li>
<li><a href="https://github.com/joomla/joomla-cms/commit/2cd4ef682f0cab6ff03200b79007a25f19c6690e" target="_blank" rel="noopener noreferrer">https://github.com/joomla/joomla-cms/commit/2cd4ef682f0cab6ff03200b79007a25f19c6690e</a></li>
<li><a href="https://www.joomla.org/announcements/release-news/5643-joomla-3-4-7.html" target="_blank" rel="noopener noreferrer">https://www.joomla.org/announcements/release-news/5643-joomla-3-4-7.html</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/dWuY7g.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>读懂PHP opcode及其在webshell检测中的应用</title>
      <link>https://mars.run/cybersecurity/%E8%AF%BB%E6%87%82PHP%20opcode%E5%8F%8A%E5%85%B6%E5%9C%A8webshell%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html</link>
      <guid>https://mars.run/cybersecurity/%E8%AF%BB%E6%87%82PHP%20opcode%E5%8F%8A%E5%85%B6%E5%9C%A8webshell%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html</guid>
      <source url="https://mars.run/rss.xml">读懂PHP opcode及其在webshell检测中的应用</source>
      <description>什么是opcode 当Zend Engine解析PHP脚本的时候，会对脚本进行词法、语法分析，然后编译成opcode来执行，类似JVM中的字节码(byte codes)，只不过opcode不会像class文件那种存在磁盘，而是在内存中直到PHP的生命周期结束。 盗一张图： opcode</description>
      <category>网络安全</category>
      <pubDate>Wed, 10 Jun 2015 16:01:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是opcode</h2>
<p>当Zend Engine解析PHP脚本的时候，会对脚本进行词法、语法分析，然后编译成opcode来执行，类似JVM中的字节码(byte codes)，只不过opcode不会像class文件那种存在磁盘，而是在内存中直到PHP的生命周期结束。</p>
<p>盗一张图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/DlYw5G.jpg" alt="opcode" tabindex="0" loading="lazy"><figcaption>opcode</figcaption></figure>
<blockquote>
<p>opcode在PHP内核中是如何生成的可以参考 :&nbsp;<a href="http://www.php-internals.com/book/?p=chapt02/02-03-02-opcode" target="_blank" rel="noopener noreferrer">http://www.php-internals.com/book/?p=chapt02/02-03-02-opcode</a></p>
</blockquote>
<p>我们可以通过PHP扩展vld来查看PHP脚本的opcode，可以参考：(<a href="http://blog.csdn.net/21aspnet/article/details/7002644" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/21aspnet/article/details/7002644)</a>)</p>
<p>Zend Engine中编译和执行PHP脚本的关键函数是：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>VLD就是通过HOOK Zend Engine中的这两个函数来实现dump opcode，来看看它的代码：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在vld_compile_file中完成HOOK:</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取opcode后将其格式化输出：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实APC、Opcache等opcode优化扩展都是用这种方式来实现的。</p>
<h2> 读懂opcode</h2>
<p>下面我们用vld生成一段opcode看看。PHP脚本如下：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行vld，输出：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>怎么去看呢？前面比较清晰，filename，function name 都是顾名思义。后面两行：</p>
<ol>
<li>number of ops：opcode的数量</li>
<li>compiled vars：PHP变量编译后的opcode表示形式，因为opcode不会使用变量的名字，而是使用变量的ID。比如后面的hello函数中，$who 对应着 !0</li>
</ol>
<p>接着是后面的表格，列名含义如下表：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>line</td>
<td>对应PHP脚本中的行数</td>
</tr>
<tr>
<td>#</td>
<td>opcode编号</td>
</tr>
<tr>
<td>*</td>
<td>貌似没用</td>
</tr>
<tr>
<td>op</td>
<td>使用的Opcode，见：<a href="https://php.net/manual/en/internals2.opcodes.php#internals2.opcodes" target="_blank" rel="noopener noreferrer">https://php.net/manual/en/internals2.opcodes.php#internals2.opcodes</a></td>
</tr>
<tr>
<td>fetch</td>
<td>不清楚</td>
</tr>
<tr>
<td>ext</td>
<td>脚本执行所需要的其他信息</td>
</tr>
<tr>
<td>return</td>
<td>返回值</td>
</tr>
<tr>
<td>operands</td>
<td>操作数</td>
</tr>
</tbody>
</table>
<p>其实这些列名对应着PHP内核中opcode结构体的成员变量：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么这段opcode的意思是：</p>
<ol>
<li>NOP是编译过程优化的结果，没什么意义。</li>
<li>把’World’作为参数传给后面的函数。</li>
<li>调用函数hello, 返回值为$0。</li>
<li>ECHO 输出$0。</li>
<li>函数结束返回。</li>
</ol>
<p>下一段是hello函数：</p>
<ol>
<li>接受传给函数的参数。</li>
<li>把’Hello%2C+%25s%21’作为参数传给后面的函数。</li>
<li>把!0作为参数传给后面的函数。</li>
<li>调用函数sprintf，返回值为$0。</li>
<li>函数返回$0。</li>
<li>函数结束。</li>
</ol>
<h2> 总结</h2>
<p>在Webshell检测中，opcode可以：（这里只讨论opcode在webshell检测中的作用）</p>
<ol>
<li>辅助检测PHP后门/Webshell。
<ol>
<li>优点：作为静态分析的辅助手段，可以快速精确定位PHP脚本中可控函数及参数的调用。</li>
<li>缺点：需要人工维护关键字，无法应对变形马，如编码、ASCII运算等等。</li>
</ol>
</li>
<li>帮助我们更加深入地理解PHP内核机制，使我们可以修改PHP源码或者以扩展的形式来动态检测PHP后门/Webshell。（HOOK关键危险函数，如eval, assert等，当GPC参数进入危险函数及有相关危险操作时，判定为后门/Webshell）
<ol>
<li>优点：上面写的缺点取反，并且误报率低，准确。</li>
<li>缺点：部署，维护成本高。</li>
</ol>
</li>
</ol>
<h2> Reference</h2>
<ol>
<li><a href="http://www.laruence.com/2008/08/14/250.html" target="_blank" rel="noopener noreferrer">http://www.laruence.com/2008/08/14/250.html</a></li>
<li><a href="http://blog.pascal-martin.fr/post/php-obtenir-dump-opcodes.html" target="_blank" rel="noopener noreferrer">http://blog.pascal-martin.fr/post/php-obtenir-dump-opcodes.html</a></li>
<li><a href="http://rancoud.com/read-phps-opcode/" target="_blank" rel="noopener noreferrer">http://rancoud.com/read-phps-opcode/</a></li>
<li><a href="http://www.php-internals.com/book/?p=chapt02/02-03-02-opcode" target="_blank" rel="noopener noreferrer">http://www.php-internals.com/book/?p=chapt02/02-03-02-opcode</a></li>
<li><a href="http://security.tencent.com/index.php/blog/msg/19" target="_blank" rel="noopener noreferrer">http://security.tencent.com/index.php/blog/msg/19</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/DlYw5G.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>PHP Challenge 2015</title>
      <link>https://mars.run/cybersecurity/PHP_Challenge_2015.html</link>
      <guid>https://mars.run/cybersecurity/PHP_Challenge_2015.html</guid>
      <source url="https://mars.run/rss.xml">PHP Challenge 2015</source>
      <description>背景 在乌云上看到PHP Challenge 2015，深感兴趣，但并无思路，直到看了@Ryat大牛的微博才知道答案。 PHP bug 先贴出代码吧</description>
      <category>网络安全</category>
      <pubDate>Tue, 10 Feb 2015 12:19:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>在乌云上看到<a href="http://zone.wooyun.org/content/22100" target="_blank" rel="noopener noreferrer">PHP Challenge 2015</a>，深感兴趣，但并无思路，直到看了<a href="https://weibo.com/3202054374/CtNpv1ov8?type=comment" target="_blank" rel="noopener noreferrer">@Ryat</a>大牛的微博才知道答案。</p>
<h2> PHP bug</h2>
<p>先贴出代码吧</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照Ryat的提示，找到(<a href="https://bugs.php.net/bug.php?id=69892" target="_blank" rel="noopener noreferrer">https://bugs.php.net/bug.php?id=69892</a>)</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>integer类型的key截断导致不同的数组比较结果相同。我们去看看PHP源码中的相关片段，在<code>Zend/zend_hash.c</code>：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键在34行:</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当数组的key为integer进到这里，比较他们的key是否相同，p1和p2是PHP的bucket结构体，其中h保存着数组的key。bucket结构如下：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出h是ulong，ulong是一个unsigned long，如下：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>看到这里不知道大家有没有看出问题？注意喔，保存p1和p2差值的变量是result，而result是int型变量，这就导致了在64位系统中，unsigned long是64位整型，而int是32位整型，类型的不同出现问题。程序会将<code>p1-&gt;h - p2-&gt;h</code>的结果强制转换为int，我们都知道unsigned long转int会截取低4个字节。所以只需要让unsigned long的低4字节为0，它转换后的int就为0。比如我们将二进制<code>10000000000000000000000000000000000000</code>转换为十进制<code>137438953472</code>，那么<code>137438953472</code>转为int就为0。</p>
<h2> 分析</h2>
<p>现在再来看看这个php代码吧，前面的那个bug利用前提是数组的value相同，key不同，所以首先需要匹配一个md5出来，我在cmd5试了这10个md5，只有第五个<code>06e2b745f3124f7d670f78eabaa94809</code>能解出，原文是<code>hund</code>。于是首先写入cookie：<code>Cookie: user[0]=5;user[1]=hund;</code>&nbsp;程序会进入58行，验证通过，$valid_user被改为true，这个时候输出为<code>Welcome back user</code>。到了这一步答案已经很接近了，只需要将$uid改为0即可。现在试试前面提到的漏洞，我们写入cookie：<code>Cookie: user[137438953472]=5;user[1]=hund;</code>&nbsp;这个时候因为之前提到的漏洞，程序还是会进入58行，因为$input[0]未赋值，所以为NULL，在PHP中<code>0+NULL=0</code>,故成功将$uid改为0。</p>
]]></content:encoded>
    </item>
    <item>
      <title>我用白板墙贴，记录日常生活</title>
      <link>https://mars.run/posts/2023-01-26-whiteboard_gtd.html</link>
      <guid>https://mars.run/posts/2023-01-26-whiteboard_gtd.html</guid>
      <source url="https://mars.run/rss.xml">我用白板墙贴，记录日常生活</source>
      <description>摆脱数字性遗忘：白板墙贴的生活/工作清单，适用于居家办公的 GTD 补充记录方案。 在数字化和网络化的时代，日常记录从纸质转移到电子存储，它带来了无限的容量和随时随地使用的便利。然而，这也带来了新的问题：如果没有打开应用程序，记录就无法提醒，容易忘记重要事情。即使设置了定时提醒，提醒时间也不一定是最佳处理时间，因此可能会延迟或取消，从而导致遗忘。为了解决这个问题，我使用白板墙贴来记录生活/工作清单。 源图：Storyset</description>
      <category>工具</category>
      <pubDate>Sun, 22 Jan 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>摆脱数字性遗忘：白板墙贴的生活/工作清单，适用于居家办公的 GTD 补充记录方案。</p>
</blockquote>
<p>在数字化和网络化的时代，日常记录从纸质转移到电子存储，它带来了无限的容量和随时随地使用的便利。然而，这也带来了新的问题：如果没有打开应用程序，记录就无法提醒，容易忘记重要事情。即使设置了定时提醒，提醒时间也不一定是最佳处理时间，因此可能会延迟或取消，从而导致遗忘。为了解决这个问题，我使用白板墙贴来记录生活/工作清单。</p>
<figure><img src="http://tc.seoipo.com/2023-01-27-05-13-50.png" alt="Website Creator Cartoon" tabindex="0" loading="lazy"><figcaption>源图：Storyset</figcaption></figure>
<h2> 为什么是白板？</h2>
<p>在中学时，我没有电脑和手机，就曾把最初的 GTD 记录在玻璃桌面上，若记录失效或不再需要，只需擦掉即可。白板墙贴与当时的玻璃桌面效果类似，只是换到墙上了。我在书房和走廊各贴了一块白板，书房的墙贴用来提醒当天要做什么，走廊的墙贴用来提醒日常生活仪式。无论走到哪里，都不会错过重要提醒。特别是在不确定下一步该做什么时，我只要转身，就能看到工作清单，非常直观和便捷。</p>
<figure><img src="http://tc.seoipo.com/2023-01-26-12-28-36.png" alt="" tabindex="0" loading="lazy"><figcaption>透明/白色静电墙贴</figcaption></figure>
<p>与电子记录相比，白板没有软件框架限制。它可以用于绘制思维导图，帮助人们更清晰地组织思路；也可以用多种颜色的记号笔随意书写和涂鸦，以原始的方式表达自己的想法。因此，白板是记录、展示信息和思考的极佳工具。</p>
<figure><img src="http://tc.seoipo.com/2023-01-25-19-21-12.png" alt="Scrum board" tabindex="0" loading="lazy"><figcaption>Scrum board</figcaption></figure>
<h2> 白板类型</h2>
<p>白板墙贴源自 @chen 在群里分享的一个很棒的主意：使用静电墙贴作为白板，可以随时记录。在尝试的过程中，我更换了三种材质：透明静电墙贴、白色静电墙贴和 PVC 墙贴（吸磁软白板贴）。</p>
<table>
  <tbody><tr>
    <th>类型</th>
    <th>透明/白板静电墙贴</th>
    <th>PVC 墙贴（非静电）</th>
    <th>支架式白板</th>
  </tr>
  <tr>
    <td>优点</td>
    <td>安装方便；轻松固定在墙上；费用低。</td>
    <td>磁吸；字迹擦拭方便；<br>黑色、白色、绿色、黛灰等多种背景可供选择。</td>
    <td>双面书写；易写易擦；可吸附性；可自由升降；可360°翻转；带刹车滑轮。</td>
  </tr>
  <tr>
    <td>缺点</td>
    <td>字迹在 24 小时后会在墙贴上留下凸起的痕迹；红色、蓝色等非黑色笔迹很难擦干净。</td>
    <td>需要使用双面胶固定；难以将其平整地贴在墙上。</td>
    <td>安装麻烦，无法贴上墙，占地方。</td>
  </tr>
  <tr>
    <td>费用</td>
    <td>20 元（120cm x 200cm）</td>
    <td>160 元（120cm x 200cm）</td>
    <td>280 元（100cm x 200cm）</td>
  </tr>
</tbody></table>
<h2> 我的方案</h2>
<p>在我的方案中，记录的想法分为日常仪式和生活/工作两类。日常仪式记录在走廊白板上，生活/工作记录则输出在书房白板上。下面我将简要介绍白板内容和思路。</p>
<figure><img src="http://tc.seoipo.com/2023-02-03-20-58-05.png" alt="" tabindex="0" loading="lazy"><figcaption>记录输入流</figcaption></figure>
<h3> 书房白板</h3>
<p>我最常待的地方是书房，所以把日常记录都放在书房白板上，用来记录当日清单、锻炼进度、思维导图、项目跟进和临时安排。书房白板使用率较高，因此建议使用易写易擦的 PVC 墙贴（吸磁软白板贴）。</p>
<figure><img src="http://tc.seoipo.com/2023-01-23-20-58-00.png" alt="" tabindex="0" loading="lazy"><figcaption>书房白板</figcaption></figure>
<figure><img src="http://tc.seoipo.com/2023-01-28-10-42-47.png" alt="" tabindex="0" loading="lazy"><figcaption>PVC 墙贴（非静电）</figcaption></figure>
<h3> 走廊白板</h3>
<p>走廊白板是对书房白板的补充，可以在书房之外的区域提醒生活仪式等内容，例如：每天早上喝杯热水自测体脂，晚上进行当日回顾和睡前准备。走廊白板擦写频率较低，可以使用便宜的静电墙贴。如果需要修改走廊白板的提示，可以用纸巾沾水擦拭。</p>
<figure><img src="http://tc.seoipo.com/2023-01-23-20-53-36.png" alt="" tabindex="0" loading="lazy"><figcaption>走廊白板</figcaption></figure>
<h3> 电子记录</h3>
<p>使用白板墙贴记录 GTD 并不意味着放弃数字化记录。相反，我可以将白板墙贴与电子记录结合起来，使用电子记录来存储详细信息，而使用白板墙贴来提醒重要事项。在「当日检视」的环节中，我会同步书房白板和电子 GTD，以确保两者的内容保持一致。这样，我就可以在保持良好的效率和组织性的同时，还可以提高记录的可靠性和可追溯性。</p>
<h2> 更多</h2>
<p>通过使用白板墙贴记录 GTD，我发现它不仅可以帮助我更好地管理时间和任务，还可以提高工作效率。因为白板墙贴是实体物品，我可以随时随地看到它，而且它是直观的，使我一目了然地了解自己的任务和进度。此外，白板墙贴可以随时更新和修改，让我可以随时调整计划和任务。白板工具填补了笔记/清单应用和个人定制需求之间的空隙。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>