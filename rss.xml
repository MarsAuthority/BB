<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://mars.run/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://mars.run/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Mars’ Blog | 记录·分享·回顾</title>
    <link>https://mars.run/</link>
    <description>开源工具、效率方法、心理学探索的自我提升笔记，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Wed, 15 Feb 2023 17:29:22 GMT</pubDate>
    <lastBuildDate>Wed, 15 Feb 2023 17:29:22 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by Mars</copyright>
    <image>
      <title>Mars’ Blog | 记录·分享·回顾</title>
      <url>https://mars.run/logo.svg</url>
      <link>https://mars.run/</link>
    </image>
    <category>网络安全</category>
    <category>工具</category>
    <item>
      <title>WordPress 3.8.2 cookie伪造漏洞及Python使用urllib2出现30x跳转的问题</title>
      <link>https://mars.run/cybersecurity/WordPress%203.8.2%20cookie%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E%E5%8F%8APython%E4%BD%BF%E7%94%A8urllib2%E5%87%BA%E7%8E%B030x%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98.html</link>
      <guid>https://mars.run/cybersecurity/WordPress%203.8.2%20cookie%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E%E5%8F%8APython%E4%BD%BF%E7%94%A8urllib2%E5%87%BA%E7%8E%B030x%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98.html</guid>
      <source url="https://mars.run/rss.xml">WordPress 3.8.2 cookie伪造漏洞及Python使用urllib2出现30x跳转的问题</source>
      <description>背景 首先看这篇文章：WordPress 3.8.2 cookie伪造漏洞再分析 http://drops.wooyun.org/papers/1409 推荐阅读： The dangers of type coercion and remote management plugins</description>
      <category>网络安全</category>
      <pubDate>Sat, 10 May 2014 15:19:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>首先看这篇文章：WordPress 3.8.2 cookie伪造漏洞再分析 <a href="http://drops.wooyun.org/papers/1409" target="_blank" rel="noopener noreferrer">http://drops.wooyun.org/papers/1409</a></p>
<p>推荐阅读：</p>
<p><a href="http://joncave.co.uk/2013/03/dangers-of-type-coercion-and-remote-management/" target="_blank" rel="noopener noreferrer">The dangers of type coercion and remote management plugins</a></p>
<p>WordPress 3.8.2修复的一个重要漏洞是cookie伪造漏洞&nbsp;<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0166" target="_blank" rel="noopener noreferrer">(CVE-2014-0166)</a>。该漏洞可以被攻击者利用通过伪造身份验证Cookie，登陆网站。</p>
<h2> 利用</h2>
<p>具体的原理请看上面这篇文章，这里就不多重复了。</p>
<p>也就是说，我们只要把cookies设置成 “admin|$expiration|0”,就可以登陆后台了。</p>
<p>思路是：</p>
<ul>
<li>1.尝试$expiration构造Cookie</li>
<li>2.GET请求到<a href="http://www.example.com/wp-admin/profile.php" target="_blank" rel="noopener noreferrer">http://www.example.com/wp-admin/profile.php</a>,根据返回的http header判断是否跳转,如为200则成功</li>
<li>3.多线程,有条件使用多机器</li>
</ul>
<h2> 题外话</h2>
<p>在写利用脚本的时候发现，python的urllib2.urlopen会遇到301/302自动跳转的问题，这样无法判断出http状态码是否是302。来分析看看为什么吧。😃</p>
<p>打开urllib2源码，刚开头就看到了相关文档：</p>
<p><code>The HTTPRedirectHandler automatically deals with HTTP 301, 302, 303 and 307 redirect errors.</code></p>
<p>仔细阅读源码看一下调用过程：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里我想已经够清楚了(执行到了我们之前在文档看到的HTTPRedirectHandler)，最后的redirect_request：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以GET遇到状态码（301, 302, 303, 307）时会Request跳转到新的地址，所以我们无法获取这些状态码(没有保存下来)。</p>
<p>我们需要自己写一个hander来重写30x方法处理这种情况，保存状态码。代码如下：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，就可以正常返回301/302状态码。</p>
<p>另外，WordPress 3.8.2补丁分析 HMAC timing attack&nbsp;<a href="http://drops.wooyun.org/papers/1404" target="_blank" rel="noopener noreferrer">http://drops.wooyun.org/papers/1404</a>&nbsp;思路确实很赞。</p>
]]></content:encoded>
    </item>
    <item>
      <title>安全数据可视化</title>
      <link>https://mars.run/cybersecurity/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%B1%87%E6%80%BB.html</link>
      <guid>https://mars.run/cybersecurity/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%B1%87%E6%80%BB.html</guid>
      <source url="https://mars.run/rss.xml">安全数据可视化</source>
      <description>tbc</description>
      <category>网络安全</category>
      <pubDate>Wed, 18 May 2022 00:00:10 GMT</pubDate>
      <content:encoded><![CDATA[<p>tbc</p>
]]></content:encoded>
    </item>
    <item>
      <title>安全数据可视化</title>
      <link>https://mars.run/cybersecurity/%E5%AE%89%E5%85%A8%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.html</link>
      <guid>https://mars.run/cybersecurity/%E5%AE%89%E5%85%A8%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.html</guid>
      <source url="https://mars.run/rss.xml">安全数据可视化</source>
      <description>概述 数据可视化主要旨在借助于图形化手段，清晰有效地传达与沟通信息。随着大数据，机器学习，EDA的发展，数据可视化变得越来越重要。在大量的数据面前，传统方法也无能为力，使用可视化的方法可以快速直观地分析/展示数据。 为什么要可视化数据？ Discovery：用于探索、观察数据，将数据转换为知识。通过视觉展示，能够给人们一些新的观察视角，以便思考、发现这些数据所包含的知识。 Understanding：通过可视化，可能会发现一些传统统计学方法/数理知识无法发现的模式/规律/关联，使得研究人员更好地使用这些数据。 Informed decisions：快速、准确地将数据所包含的信息传递给读者，在损失一些细节的同时，在几秒钟的时间内将信息传递出去。</description>
      <category>网络安全</category>
      <pubDate>Sun, 19 Jun 2016 22:00:10 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>数据可视化主要旨在借助于图形化手段，清晰有效地传达与沟通信息。随着大数据，机器学习，EDA的发展，数据可视化变得越来越重要。在大量的数据面前，传统方法也无能为力，使用可视化的方法可以快速直观地分析/展示数据。</p>
<h2> 为什么要可视化数据？</h2>
<ol>
<li>Discovery：用于探索、观察数据，将数据转换为知识。通过视觉展示，能够给人们一些新的观察视角，以便思考、发现这些数据所包含的知识。</li>
<li>Understanding：通过可视化，可能会发现一些传统统计学方法/数理知识无法发现的模式/规律/关联，使得研究人员更好地使用这些数据。</li>
<li>Informed decisions：快速、准确地将数据所包含的信息传递给读者，在损失一些细节的同时，在几秒钟的时间内将信息传递出去。</li>
</ol>
<p>引用<a href="https://weibo.com/u/3181671860" target="_blank" rel="noopener noreferrer">宫一鸣</a>说的：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/QloZrX.jpg" alt="宫一鸣微博" tabindex="0" loading="lazy"><figcaption>宫一鸣微博</figcaption></figure>
<p>《Data-Driven Security: Analysis.Visualization and Dashboards》一书描述了通过了解人类视觉信息系统的运作，来帮助我们创造出优秀数据可视化：视觉信息通过眼睛，从光转化成电信号，这些信息经过<strong>视觉记忆(visual memory)<strong>的若干阶段，每个阶段都有特定的强度、限制以及功能。在我们能够意识到这些信息之前，大脑会快速地扫描视觉区域，这就是</strong>前注意处理(preattentive processing)</strong>。最后，大脑会让眼睛进行一系列的**扫视运动(saccadic movement)，**我们会聚焦在不同的特征上面，来帮助大脑建立视觉画面。</p>
<h3> 视觉记忆</h3>
<ul>
<li>图像记忆：视觉信息在这里进行十分短暂的停留。这是人们对视觉信息的第一印象，可以通过颜色、形状和其他线条来抓住观众的注意力以及传递一些数据的基本属性信息。</li>
<li>工作记忆：在这个阶段，根据任务和对象不同，大脑仅可以容纳三到五个对象，所以在展示数据的时候，应该限制每个视觉效果内部超过五个对象。</li>
<li>长期记忆：能够保持几天到几年的记忆，短期记忆是神经连接的暂时性强化，生理上的结构是反响回路（reverberatory circuit），而通过巩固后、可变为长期记忆。</li>
</ul>
<h3> 前注意处理</h3>
<p>平时我们在记笔记，画脑图的时候就不知不觉的运用了前注意处理的特点了，即画重点，分类标记等等。前注意处理可以很好地智能分组和聚集重要信息，通过强化部分视觉属性，可以轻松做的这一点，如：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/c4Eznn.jpg" alt="c4Eznn" tabindex="0" loading="lazy"><figcaption>c4Eznn</figcaption></figure>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/sphQ3z.jpg" alt="sphQ3z" tabindex="0" loading="lazy"><figcaption>sphQ3z</figcaption></figure>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/8F3g1w.jpg" alt="8F3g1w" tabindex="0" loading="lazy"><figcaption>8F3g1w</figcaption></figure>
<h2> <strong><strong>扫视运动</strong></strong></h2>
<p>人们在观察事物的时候，眼球会快速地各处移动，通过一系列的观察来建立整个图像。在我们观察一个可视化图像的时候也会这样，人的眼睛会注视在有明显特征的区域，然后在重要的点之间来回跳动，因此我们应该：</p>
<ul>
<li>不要在仪表盘上过多地展示视觉特征</li>
<li>赋予重要信息更明显的视觉特征</li>
<li>限制扫视运动耗费的时间</li>
</ul>
<h2> 可视化分析</h2>
<h3> 相关知识</h3>
<ul>
<li>统计学知识：很多数据都是数值型(numeric)的，因此均值、中值、方差、标准差、正态分布、蒙特·卡罗方法等等这些东西很有用。</li>
<li>可视化知识：美学及可视化方法的选择。</li>
<li>安全知识：识别误报、安全事件、安全事故等等。</li>
</ul>
<h3> 思考目标</h3>
<p>目标驱动而不是数据驱动。要清楚可视化这些数据的目标是什么，是分析数据找出规律/异常？还是直观的展示数据？还是其他用途？</p>
<h2> 数据预处理</h2>
<ul>
<li>数据清理：清洗脏数据</li>
<li>数据集成：将多文件或者多数据库中的异构数据进行合并，然后存放在一个一致的数据存储中。考虑以下几个问题： 1.模式匹配 2.数据冗余 3.数据值冲突</li>
<li>数据变换：1.平滑 2.聚集 3.数据概化 4.规范化：(1)最小-最大规范化 (2)零-均值规范化 (3)小数定标规范化 5.属性构造</li>
<li>数据规约：数据过大的情况下，使用数据归约技术获得比原始数据小的多的，但不破坏数据完整性的数据集，该数据集可以得到与原始数据相同的结果</li>
</ul>
<p>通过可视化手段，我们可以：</p>
<ol>
<li>综合信息，从海量、动态、模糊、矛盾的数据中获取深入的了解。</li>
<li>从可视化中得出意想不到的结论、证实猜想。</li>
<li>实时地将数据转换为有用的知识。</li>
</ol>
<p>可视化在数据挖掘中也非常重要，他是连接从数据升华到知识这个过程的桥梁，快速直观地发现数据中存在的规则，特性，走势等等，辅助数据分析及建模过程。前面的<a href="http://mars.run/2015/11/Machine%20learning%20kaggle%20titanic-0.8/" target="_blank" rel="noopener noreferrer">机器学习实战之Kaggle_Titanic预测</a>就大量使用了可视化技术来辅助分析。</p>
<p>下图是可视化分析概览：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/dUD5Sp.jpg" alt="概览" tabindex="0" loading="lazy"><figcaption>概览</figcaption></figure>
<h2> 常见应用</h2>
<table>
<thead>
<tr>
<th>分析</th>
<th>数据名称</th>
<th>数据源示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>流量监控</td>
<td>网络数据包日志</td>
<td>Tcpdump,Wireshark</td>
</tr>
<tr>
<td></td>
<td>网络数据包日志</td>
<td>CiscoNetFlow</td>
</tr>
<tr>
<td>状态监控</td>
<td>状态监控日志</td>
<td>BigBrother,vSphere</td>
</tr>
<tr>
<td>事件监控</td>
<td>IDS/IPS日志</td>
<td>Snort，Bro</td>
</tr>
<tr>
<td></td>
<td>防火墙日志</td>
<td>Cisco，Checkpoint</td>
</tr>
<tr>
<td></td>
<td>网络应用操作日志</td>
<td>Apache，Nginx，Exchange，DNS</td>
</tr>
<tr>
<td></td>
<td>漏洞扫描与监控日志</td>
<td>Fortify，Nessus，Zabbix</td>
</tr>
<tr>
<td>其他日志</td>
<td>数据库日志，系统日志等等</td>
<td></td>
</tr>
</tbody>
</table>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/tfEAXK.jpg" alt="常见应用" tabindex="0" loading="lazy"><figcaption>常见应用</figcaption></figure>
<h2> 参考资料</h2>
<ol>
<li><a href="http://www.cqvip.com/read/read.aspx?id=27784761" target="_blank" rel="noopener noreferrer">网络安全可视化研究综述</a></li>
<li><a href="https://item.jd.com/11771405.html" target="_blank" rel="noopener noreferrer">数据驱动安全：数据安全分析、可视化和仪表盘</a></li>
<li><a href="https://www.perceptualedge.com/blog/?p=1897" target="_blank" rel="noopener noreferrer">Visual Business Intelligence</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/QloZrX.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>N-gram在安全领域的应用</title>
      <link>https://mars.run/cybersecurity/N-gram%E5%9C%A8%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8.html</link>
      <guid>https://mars.run/cybersecurity/N-gram%E5%9C%A8%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8.html</guid>
      <source url="https://mars.run/rss.xml">N-gram在安全领域的应用</source>
      <description>什么是N-Gram？ N-Gram是一种在自然语言处理(NLP)中常用的一种概率语言模型(Probabilistic Language Model)，常用于语音\手写识别、机器翻译、拼写纠错等等领域。 它的本质就是计算一个句子或者一连串词出现的概率。 /* T 是由 W1,W2,W3,W4,W5 ... Wn组成的一个句子。 */ P(T) = P(W1,W2,W3,W4,W5 ... Wn) //这个句子出现的概率是里面每一个词出现的概率的叠加。 P(W5|W1,W2,W3,W4) //已经出现第1个至第4个的词的情况下，第5个词出现的概率。</description>
      <category>网络安全</category>
      <pubDate>Sun, 19 Jun 2016 22:00:10 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是N-Gram？</h2>
<p>N-Gram是一种在自然语言处理(NLP)中常用的一种概率语言模型(Probabilistic Language Model)，常用于语音\手写识别、机器翻译、拼写纠错等等领域。</p>
<p>它的本质就是计算一个句子或者一连串词出现的概率。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/r9iFeU.jpg" alt="Google" tabindex="0" loading="lazy"><figcaption>Google</figcaption></figure>
<p>I am working 后面很有可能出现<code>at</code>,&nbsp;<code>in</code>,&nbsp;<code>for</code>&nbsp;，而不是<code>refrigerator</code>,&nbsp;<code>throw</code>,&nbsp;<code>gull</code>。那么如何计算N-Grams呢？我们可以使用链式法则(<a href="https://en.wikipedia.org/wiki/Chain_rule_(probability)" target="_blank" rel="noopener noreferrer">Chain Rule</a>)，求多个关联事件并存时的概率：</p>
<ul>
<li>2个事件同时发生的概率：<strong>P(a, b) = P(a | b) * P(b)</strong></li>
<li>3个事件的概率链式调用：<strong>P(a, b, c) = P(a | b, c) * P(b, c) = P(a | b, c) * P(b | c) * P(c)</strong></li>
<li>推广到N个事件，概率链式法则为：<strong>P(X1, X2, ... Xn) = P(X1 | X2, X3 ... Xn) * P(X2 | X3, X4 ... Xn) ... P(Xn-1 | Xn) * P(Xn)</strong></li>
</ul>
<p>但是这样会有两个问题：</p>
<ol>
<li>参数空间过大，不可能实用化。（N越大越难计算）</li>
<li>数据稀疏严重，语言有各种各样的组合，数据量太大，无法获取这么全的数据。</li>
</ol>
<p>所以为了简化这个问题，我们引入马尔科夫假设（Markov Assumption）：”一个词的出现仅仅依赖于它前面出现的一个或者有限的几个词。”</p>
<ol>
<li>如果一个词的出现仅仅依赖于它本身，我们称之为 Uni-gram model :&nbsp;<code>P(T) = P(W1)P(W2)...P(Wn)</code></li>
<li>如果一个词的出现仅仅依赖于它前面出现的一个词，我们称之为 Bi-gram model :&nbsp;<code>P(T) = P(W1)P(W2|W1)P(W3|W2)...P(Wn|Wn-1)</code></li>
<li>如果一个词的出现仅仅依赖于它前面出现的两个词，我们称之为 Tri-gram model :&nbsp;<code>P(T) = P(W1)P(W3|W1,W2)...P(Wn|Wn-2,Wn-1)</code></li>
<li>依次类推到仅依赖于它前面出现的N个词，还有4-gram, 5-gram。</li>
</ol>
<p>下面用Bi-gram举个例子，语料库来自&nbsp;<a href="http://www1.icsi.berkeley.edu/Speech/berp.html" target="_blank" rel="noopener noreferrer">[Berkeley Restaurant Project]</a>&nbsp;，总词数为 10132。</p>
<p>词和词频率：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>want</th>
<th>to</th>
<th>eat</th>
<th>chinese</th>
<th>food</th>
<th>lunch</th>
<th>spend</th>
</tr>
</thead>
<tbody>
<tr>
<td>2533</td>
<td>927</td>
<td>2417</td>
<td>746</td>
<td>158</td>
<td>1093</td>
<td>341</td>
<td>278</td>
</tr>
</tbody>
</table>
<p>词序列频率：</p>
<table>
<thead>
<tr>
<th>*</th>
<th>i</th>
<th>want</th>
<th>to</th>
<th>eat</th>
<th>chinese</th>
<th>food</th>
<th>lunch</th>
<th>spend</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>5</td>
<td>827</td>
<td>0</td>
<td>9</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>want</td>
<td>2</td>
<td>0</td>
<td>608</td>
<td>1</td>
<td>6</td>
<td>6</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>to</td>
<td>2</td>
<td>0</td>
<td>4</td>
<td>686</td>
<td>2</td>
<td>0</td>
<td>6</td>
<td>211</td>
</tr>
<tr>
<td>eat</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>16</td>
<td>2</td>
<td>42</td>
<td>0</td>
</tr>
<tr>
<td>chinese</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>82</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>food</td>
<td>15</td>
<td>0</td>
<td>15</td>
<td>0</td>
<td>1</td>
<td>4</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>lunch</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>spend</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>9</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>根据上表我们可以直观的看出，在这八个词的组合中，概率最高的句子是： i want to eat lunch 。它的概率是 P(i want to eat lunch) = P(i)P(want|i)P(to|want)P(eat|to)P(lunch|eat) = 2533/10132&nbsp;* <em>827/2533</em>&nbsp;* 608/927&nbsp;* <em>686/2417</em>&nbsp;* 42/746 = 0.25&nbsp;* <em>0.326</em>&nbsp;* 0.656&nbsp;* <em>0.284</em>&nbsp;* 0.056 = 0.00085</p>
<h3> Smoothing</h3>
<p>随着N-Grams的N的增大，N-Grams的数量对越来越多。如果词表中有10000个词，Bi-Gram模型可能产生100000000个N-Gram，Tri-Gram模型则可能产生1000000000000个N-Gram，那么会出现(unseen events)，词库中的某些词在训练样本中没有的情况（比如<code>in</code>在训练样本中没有出现在<code>turn</code>
后面）。为了避免在这种情况下概率为0，我们使用Smoothing来解决。</p>
<ol>
<li>
<p>add-1 smoothing : 很简单，给所有统计的counts加 1 。</p>
</li>
<li>
<p>add-k smoothing : 将高概率分到unseen events，在计算概率的时候，选择一个合适的k值。</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/MEKSo5.jpg" alt="add-k" tabindex="0" loading="lazy"><figcaption>add-k</figcaption></figure>
</li>
<li>
<p>backoff ： 如果Tri-gram统计为0，就去看Bi-gram，以此类推。</p>
</li>
<li>
<p>interpolation : 以权重，将Tri-gram，Bi-gram，Uni-gram综合起来。（举例）</p>
</li>
<li>
<p>kneser-ney smoothing : 以地位向高位，或者高位向地位的方向，传递高频。</p>
</li>
</ol>
<h2> 使用Python生成N-grams</h2>
<p>简单的实现：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> NIDS中的应用</h2>
<h3> 案例一</h3>
<p>Ke Wang 和 Salvatore J. Stolfo 在《Anomalous Payload-based Network Intrusion Detection 》中提出了一种基于1-Gram的方法，将数据包以端口分类，相同端口的数据包再以不同的长度分类，然后计算出ASCII字符0-255的平均分布频率，作为一个特征，加上平均分布频率的平均值，方差，标准差作为另一个特征。有了这两个特征，就可以在异常检测中建立模型，完成任务。如下图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/qvrUtF.jpg" alt="案例一" tabindex="0" loading="lazy"><figcaption>案例一</figcaption></figure>
<p>整个思路是：是训练阶段，算出不同端口/长度数据包的平均字节概率分布模型(平均值，方差，标准差)，预测阶段，算出新数据包的字节概率分布模型，使用马氏距离(Mahalanobis distance)，比较两个模型的差异，当差异超过某个阈值的时候，则检测出异常。还加上了增量学习(Incremental learning)使整个模型随着新数据的到来，不断的更新自己的参数(平均值，方差，标准差)，”淘汰”旧数据，”更新”新数据。</p>
<p>文中还提到了一种实现签名检测的方法：将字节的平均概率分布图，把频率从高到低进行重排序。这样得出的分布图很像Zipf-like分布(指数函数/幂函数少数值频繁出现，多数值偶尔出现。通俗地讲，就是二八原则：80%的财富集中在20%的人手中……80%的用户只使用20%的功能……20%的用户贡献了80%的访问量……)，这样用很小的长度就表示了整个ASCII范围的平均概率分布。比如下图，重排序后只用83个unique 的字符就表示了整个平均概率分布。</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/frPmAf.jpg" alt="案例一" tabindex="0" loading="lazy"><figcaption>案例一</figcaption></figure>
<p>通过这种方法将已识别/确认的异常数据包做成签名(signature)，可以快速准确地检测其他地方可能出现的相同异常数据包。</p>
<h3> 案例二</h3>
<p>前面说到的方法是1-Gram的应用，然而1-Gram的简单性(平均字节概率分布)很容易受到拟态攻击(mimicry attacks)，攻击者可以通过填充无用字符的方法来伪造出正常的概率分布，从而绕过检测。于是他们又提出了基于N-gram N大于1 的方法。见《Anagram: A Content Anomaly Detector Resistant to Mimicry Attack》</p>
<p>N-gram的本质和1-Gram是一样的，只不过特征空间变大大，在计算的时间/内存开销也很大。比如一个TCP 数据包，长度是256，那么他的N-garm就有256^n。作者通过选取几个N值，比如3-Gram, 4-Gram, 5-Gram等等，然后用Bloom filter(原理相当于哈希表)进行存储。最后在ROC曲线中比较这些N-gram的召回率与准确率，选取合适的模型。如图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/JsmuVT.jpg" alt="案例二" tabindex="0" loading="lazy"><figcaption>案例二</figcaption></figure>
<p>其他细节就略过，感兴趣可以自己查阅。</p>
<h2> 其他应用</h2>
<p>N-gram在安全领域还有很多其他的应用，比如HIDS(通过系统调用做异常检测)、恶意软件分类/识别、敏感词识别/屏蔽等等。但是效果却不好，误报、漏报严重。原因之前也提过，比如：测试还在用DARPA1999, KDD99等老样本、模型存在偏差样本性、缺乏实践等等问题。</p>
<p>开源项目参考：</p>
<p><a href="https://github.com/chwress/salad" target="_blank" rel="noopener noreferrer">https://github.com/chwress/salad</a></p>
<h2> 参考资料</h2>
<ol>
<li><a href="http://academiccommons.columbia.edu/catalog/ac%3A125704" target="_blank" rel="noopener noreferrer">Anomalous Payload-based Network Intrusion Detection</a></li>
<li><a href="http://ids.cs.columbia.edu/sites/default/files/anagram-camera-fixed.pdf" target="_blank" rel="noopener noreferrer">Anagram: A Content Anomaly Detector Resistant to Mimicry Attack</a></li>
<li><a href="https://lagunita.stanford.edu/c4x/Engineering/CS-224N/asset/slp4.pdf" target="_blank" rel="noopener noreferrer">N-Grams tutorial</a></li>
<li><a href="https://en.wikipedia.org/wiki/N-gram" target="_blank" rel="noopener noreferrer">N-Grams wikipedia</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/r9iFeU.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>入侵检测系统如何降低误报率？</title>
      <link>https://mars.run/cybersecurity/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E8%AF%AF%E6%8A%A5%E7%8E%87%EF%BC%9F.html</link>
      <guid>https://mars.run/cybersecurity/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E8%AF%AF%E6%8A%A5%E7%8E%87%EF%BC%9F.html</guid>
      <source url="https://mars.run/rss.xml">入侵检测系统如何降低误报率？</source>
      <description>背景 入侵检测技术一般分为异常检测和特征/签名检测，这里主要讨论的是网络入侵检测系统(NIDS)。 异常检测 (Anomaly detection)：假设入侵者活动异常于正常主体的活动。常用的方法有：关联规则、神经网络、SVM、邻近算法、隐含马尔可夫模型、Kalman过滤器、聚类算法、PCA、信息论等等。缺点是：需要训练样本、误报率（异常行为≠入侵行为）高。 特征/签名检测 (Misuse/Signature detection)：假设入侵者活动可以用一种模式来表示，然后将观察对象与之进行比较，判别是否符合这些模式。常用的方法有：关联规则、神经网络、SVM、决策树、遗传算法、贝叶斯网络等等。缺点是：对新的入侵方法无能为力。</description>
      <category>网络安全</category>
      <pubDate>Wed, 06 Apr 2016 18:05:13 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>入侵检测技术一般分为异常检测和特征/签名检测，这里主要讨论的是网络入侵检测系统(NIDS)。</p>
<ol>
<li>异常检测 (Anomaly detection)：假设入侵者活动异常于正常主体的活动。常用的方法有：关联规则、神经网络、SVM、邻近算法、隐含马尔可夫模型、Kalman过滤器、聚类算法、PCA、信息论等等。缺点是：需要训练样本、误报率（异常行为≠入侵行为）高。</li>
<li>特征/签名检测 (Misuse/Signature detection)：假设入侵者活动可以用一种模式来表示，然后将观察对象与之进行比较，判别是否符合这些模式。常用的方法有：关联规则、神经网络、SVM、决策树、遗传算法、贝叶斯网络等等。缺点是：对新的入侵方法无能为力。</li>
</ol>
<p>主流的入侵检测系统通常是采用异常检测+特征/签名检测。他们都存在的问题就是：</p>
<ol>
<li>告警的基数大，即使只有1%的误报率，也会产生大量的误报告警。</li>
<li>误报率往往跟漏报率成反比，改进算法降低误报率可能会增加漏报率，降低系统的可靠性。</li>
<li>大量的告警需要人工审核，造成疲惫和不信任感。</li>
</ol>
<h2> 基于输出数据(Outgoing data)</h2>
<p>完整的数据流应该包括输入和输出两个部分，而大部分NIDS却只考虑了输入数据，没有使用输出数据。通常情况下，存在异常/恶意输入数据，并不意味着有成功的入侵行为。比如一个任意文件读取的HTTP请求，只有当它的响应体中包含那个文件的内容，才算是一个成功的入侵行为。所以降低误报率的一个方法就是对输入和输出数据进行关联分析。而输出的异常检测，就是另一种方法。</p>
<p>输出数据有以下几个问题：</p>
<ol>
<li>不同程序/服务的输出数据不同，而且在使用的过程中，输出数据可能会一直变化。</li>
<li>不同程序/服务对于一种攻击类型做出的反应不同（比如一个SQL注入的HTTP请求，有些程序直接阻断，有些程序做了过滤，正常返回）。</li>
<li>如何把输入和输出数据关联起来？</li>
</ol>
<p>那么这种降低误报的方法就是在传统的基于输入的NIDS的基础上，增加：1、输入输出数据的关联分析。2、输出数据的异常检测。结构如下：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/HAObFW.jpg" alt="结构" tabindex="0" loading="lazy"><figcaption>结构</figcaption></figure>
<p><code>一次成功的攻击行为一定会引起程序/服务的异常输出(输出数据、响应时间、其他行为等等)</code>。当NIDS触发告警，关联引擎查看该告警对应的输出数据是否有异常，如果存在异常才认定为True positive。也可将攻击行为分类，关联分析输出数据是否符合该攻击行为的响应。当然，这也存在着许多缺点：1、每个程序/服务第一需要大量的样本训练。2、程序/服务的某些特征出现变动，需要重新训练样本。3、输出数据太多(比如我司http下行流量4GB/s)，收集、训练成本太高。4、其他…</p>
<h2> 基于威胁模型(Thread Model)</h2>
<p>NIDS的目的就是随时发现可能的入侵行为，并进行具体分析，及时、主动地进行干预(发送告警)，从而取得防患于未然的效果，也就是说降低风险。在风险管理中，<code>Risk = (probablity of the accident occuring) x (expected loss in case of accident)</code>。其中(expected loss in case of accident)可以理解的攻击的类型，常见的有三类：</p>
<ol>
<li>信息收集类（域名/IP/服务/端口扫描、漏洞扫描器等）</li>
<li>拒绝服务类（带宽、资源消耗）</li>
<li>程序/服务攻击（获取权限、数据库、Shell等等）</li>
</ol>
<p>其中第三种类型的攻击造成的损失最大，而第一种类型的攻击并不会立马带来什么损失，所以针对不同类型的攻击，应当给予不同的分数（每种类型的攻击还可以细分）。同时，(probablity of the accident occuring)可以理解为攻击发生的概率，那么同一输入数据/类型攻击的告警数量越多是不是意味着攻击发生的概率大呢？结合这两点因素，组成一个评分系统，再评估出一个合理的阈值，认为所有小于阈值的告警都是误报。</p>
<h2> 改进算法/训练样本/模型</h2>
<p>这一块任重而道远（比如：测试还在用DARPA1999, KDD99等样本、模型存在偏差样本性、缺乏实践等等问题），在此就不细谈了，下图是相关的研究：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/en0vmf.jpg" alt="相关研究" tabindex="0" loading="lazy"><figcaption>相关研究</figcaption></figure>
<h2> 参考资料</h2>
<ol>
<li>Damiano Bolzoni, Sandro Etalle. APHRODITE: an Anomaly-based Architecture for False Positive Reduction</li>
<li><a href="https://www.symantec.com/connect/articles/strategies-reduce-false-positives-and-false-negatives-nids" target="_blank" rel="noopener noreferrer">http://www.symantec.com/connect/articles/strategies-reduce-false-positives-and-false-negatives-nids</a></li>
<li>Asieh Mokarian, Ahmad Faraahi, Arash Ghorbannia Delavar. False Positives Reduction Techniques in Intrusion Detection Systems-A Review</li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/HAObFW.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Joomla 3.4.7 修复的反序列化与SQL注入</title>
      <link>https://mars.run/cybersecurity/Joomla%203.4.7%20%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8ESQL%E6%B3%A8%E5%85%A5.html</link>
      <guid>https://mars.run/cybersecurity/Joomla%203.4.7%20%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8ESQL%E6%B3%A8%E5%85%A5.html</guid>
      <source url="https://mars.run/rss.xml">Joomla 3.4.7 修复的反序列化与SQL注入</source>
      <description>反序列化漏洞修复分析 前一阵子 Joomla 的对象注入很火，而官方3.4.6的修复仅仅是严格过滤了X_FORWARDED_FOR、注释了USER_AGENT存入SESSION那一句，见这里,这样只是指哪补哪，治标不治本。看来官方上次的修复只是临时解决方案，这次的更新(3.4.7)算是彻底解决了此问题。</description>
      <category>网络安全</category>
      <pubDate>Tue, 20 Oct 2015 08:08:11 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 反序列化漏洞修复分析</h2>
<p>前一阵子 Joomla 的对象注入很火，而官方3.4.6的修复仅仅是严格过滤了X_FORWARDED_FOR、注释了USER_AGENT存入SESSION那一句，见<a href="https://github.com/joomla/joomla-cms/commit/995db72ff4eaa544e38b4da3630b7a1ac0146264#diff-aba80b5850bf0435954b29dece250cbfL1021" target="_blank" rel="noopener noreferrer">这里</a>,这样只是指哪补哪，治标不治本。看来官方上次的修复只是临时解决方案，这次的更新(3.4.7)算是彻底解决了此问题。</p>
<p>上次的对象注入，需要满足三个条件：</p>
<ol>
<li>自己实现session的处理方式，重新实现了 session 存储的read()和write()方法，但是并没有对 session 的值进行安全处理。</li>
<li>Mysql非strict mode下，使用utf8mb4字符&nbsp;<code>\xF0\x9D\x8C\x86</code>&nbsp;来截断。</li>
<li>PHP &lt;= 5.6.13 session中反序列化解析的BUG。</li>
</ol>
<p>Joomla 官方也只能解决第一个，也就是改进session的处理方式。这次更新，在 libraries/cms/version/version.php 中，将SESSION存储在内部的Registry类对象中，弃用了以前使用 $_SESSION[$namespace][$name] 的方式：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>并且，在写SESSION的时候会先做base64_encode：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，$_SESSION 就只剩下了$_SESSION[‘joomla’]，而且$_SESSION[‘joomla’] 只存储了Registry的对象$data，在执行read()和write()时候，SESSION是经过base64_encode后的数据，就不会存在read()之后自动反序列化而导致对象注入了。</p>
<p>在反序列化的时候也不存在unserialize参数可控的情况。（可控的只是$data的成员变量）</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Joomla官方这次的解决方案比较好，不像上次那样治标不治本，这样的态度值得称赞。反观Apache对struts2 漏洞的修复…就不说了。</p>
<h2> SQL注入漏洞分析</h2>
<h3> 漏洞分析</h3>
<p>代码位于，administrator/components/com_categories/models/category.php，save()函数内：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 $associations 未经过适当处理、我们跟着流程来看看。</p>
<p>首先，<code>$assoc = $this-&gt;getAssoc();</code>&nbsp;为 True 的时候整个逻辑才能进来，这个<code>getAssoc()</code>是什么呢？跟进getAssoc()的实现(文件的 1234 行)，发现关键是在：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>搜索一下，发现 JLanguageAssociations 是 Joomla 的一个多语言插件&nbsp;<a href="http://www.slideshare.net/erictiggeler/creating-a-multilingual-site-in-joomla-joomla-3-beginners-guide-eric-tiggeler" target="_blank" rel="noopener noreferrer">http://www.slideshare.net/erictiggeler/creating-a-multilingual-site-in-joomla-joomla-3-beginners-guide-eric-tiggeler</a>, 这个插件是 Joomla 自带的，默认没有开启，我们在后台将他开启。</p>
<p>然后，继续看代码，<code>$associations = $data['associations'];</code>, $data是post过来的数据，$associations没有经过过滤就传到了：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>导致SQL注入。</p>
<p>那 Joomla 有没有全局过滤呢？我们看看 Joomla 是如何处理POST数据的。</p>
<p>在 libraries/legacy/controller/form.php , save() 函数，</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>validate() 函数在 libraries/legacy/model/form.php 302行, 他又调用了libraries/joomla/form/form.php 的filter() 函数，具体实现就不继续了，总之这里的POST参数只是处理了 ‘ XSS and specified bad code. ‘。</p>
<p>最后，构造POC。在修改分类，保存的时候，修改POST数据:</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jform[associations][en-GB] 这个参数就是 $associations，成功注入。</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/dWuY7g.jpg" alt="Jommla" tabindex="0" loading="lazy"><figcaption>Jommla</figcaption></figure>
<blockquote>
<p>这里打一波广告，我们的Skywolf是可以轻松检测出来的，如下图</p>
</blockquote>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/vwJyVt.jpg" alt="Skywolf" tabindex="0" loading="lazy"><figcaption>Skywolf</figcaption></figure>
<p>另外，<code>libraries/legacy/model/admin.php</code> 这里也存在着同样的问题。</p>
<h3> 修复方案</h3>
<p>官方增加了：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将 $associations 中的所有值转换为int型。还有将 $id 强制转换为int。</p>
<h2> 参考资料</h2>
<ol>
<li><a href="http://drops.wooyun.org/papers/11330" target="_blank" rel="noopener noreferrer">http://drops.wooyun.org/papers/11330</a></li>
<li><a href="http://drops.wooyun.org/papers/11371" target="_blank" rel="noopener noreferrer">http://drops.wooyun.org/papers/11371</a></li>
<li><a href="http://bobao.360.cn/learning/detail/2501.html" target="_blank" rel="noopener noreferrer">http://bobao.360.cn/learning/detail/2501.html</a></li>
<li><a href="https://github.com/joomla/joomla-cms/commit/2cd4ef682f0cab6ff03200b79007a25f19c6690e" target="_blank" rel="noopener noreferrer">https://github.com/joomla/joomla-cms/commit/2cd4ef682f0cab6ff03200b79007a25f19c6690e</a></li>
<li><a href="https://www.joomla.org/announcements/release-news/5643-joomla-3-4-7.html" target="_blank" rel="noopener noreferrer">https://www.joomla.org/announcements/release-news/5643-joomla-3-4-7.html</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/dWuY7g.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>读懂PHP opcode及其在webshell检测中的应用</title>
      <link>https://mars.run/cybersecurity/%E8%AF%BB%E6%87%82PHP%20opcode%E5%8F%8A%E5%85%B6%E5%9C%A8webshell%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html</link>
      <guid>https://mars.run/cybersecurity/%E8%AF%BB%E6%87%82PHP%20opcode%E5%8F%8A%E5%85%B6%E5%9C%A8webshell%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html</guid>
      <source url="https://mars.run/rss.xml">读懂PHP opcode及其在webshell检测中的应用</source>
      <description>什么是opcode 当Zend Engine解析PHP脚本的时候，会对脚本进行词法、语法分析，然后编译成opcode来执行，类似JVM中的字节码(byte codes)，只不过opcode不会像class文件那种存在磁盘，而是在内存中直到PHP的生命周期结束。 盗一张图： opcode</description>
      <category>网络安全</category>
      <pubDate>Wed, 10 Jun 2015 16:01:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是opcode</h2>
<p>当Zend Engine解析PHP脚本的时候，会对脚本进行词法、语法分析，然后编译成opcode来执行，类似JVM中的字节码(byte codes)，只不过opcode不会像class文件那种存在磁盘，而是在内存中直到PHP的生命周期结束。</p>
<p>盗一张图：</p>
<figure><img src="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/DlYw5G.jpg" alt="opcode" tabindex="0" loading="lazy"><figcaption>opcode</figcaption></figure>
<blockquote>
<p>opcode在PHP内核中是如何生成的可以参考 :&nbsp;<a href="http://www.php-internals.com/book/?p=chapt02/02-03-02-opcode" target="_blank" rel="noopener noreferrer">http://www.php-internals.com/book/?p=chapt02/02-03-02-opcode</a></p>
</blockquote>
<p>我们可以通过PHP扩展vld来查看PHP脚本的opcode，可以参考(<a href="http://blog.csdn.net/21aspnet/article/details/7002644" target="_blank" rel="noopener noreferrer">http://blog.csdn.net/21aspnet/article/details/7002644)。</a>%E3%80%82)</p>
<p>Zend Engine中编译和执行PHP脚本的关键函数是：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>VLD就是通过HOOK Zend Engine中的这两个函数来实现dump opcode，来看看它的代码：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在vld_compile_file中完成HOOK:</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取opcode后将其格式化输出：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实APC、Opcache等opcode优化扩展都是用这种方式来实现的。</p>
<h2> 读懂opcode</h2>
<p>下面我们用vld生成一段opcode看看。PHP脚本如下：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行vld，输出：</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>怎么去看呢？前面比较清晰，filename，function name 都是顾名思义。后面两行：</p>
<ol>
<li>number of ops：opcode的数量</li>
<li>compiled vars：PHP变量编译后的opcode表示形式，因为opcode不会使用变量的名字，而是使用变量的ID。比如后面的hello函数中，$who 对应着 !0</li>
</ol>
<p>接着是后面的表格，列名含义如下表：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>line</td>
<td>对应PHP脚本中的行数</td>
</tr>
<tr>
<td>#</td>
<td>opcode编号</td>
</tr>
<tr>
<td>*</td>
<td>貌似没用</td>
</tr>
<tr>
<td>op</td>
<td>使用的Opcode，见：<a href="https://php.net/manual/en/internals2.opcodes.php#internals2.opcodes" target="_blank" rel="noopener noreferrer">https://php.net/manual/en/internals2.opcodes.php#internals2.opcodes</a></td>
</tr>
<tr>
<td>fetch</td>
<td>不清楚</td>
</tr>
<tr>
<td>ext</td>
<td>脚本执行所需要的其他信息</td>
</tr>
<tr>
<td>return</td>
<td>返回值</td>
</tr>
<tr>
<td>operands</td>
<td>操作数</td>
</tr>
</tbody>
</table>
<p>其实这些列名对应着PHP内核中opcode结构体的成员变量：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么这段opcode的意思是：</p>
<ol>
<li>NOP是编译过程优化的结果，没什么意义。</li>
<li>把’World’作为参数传给后面的函数。</li>
<li>调用函数hello, 返回值为$0。</li>
<li>ECHO 输出$0。</li>
<li>函数结束返回。</li>
</ol>
<p>下一段是hello函数：</p>
<ol>
<li>接受传给函数的参数。</li>
<li>把’Hello%2C+%25s%21’作为参数传给后面的函数。</li>
<li>把!0作为参数传给后面的函数。</li>
<li>调用函数sprintf，返回值为$0。</li>
<li>函数返回$0。</li>
<li>函数结束。</li>
</ol>
<h2> 总结</h2>
<p>在Webshell检测中，opcode可以：（这里只讨论opcode在webshell检测中的作用）</p>
<ol>
<li>辅助检测PHP后门/Webshell。
<ol>
<li>优点：作为静态分析的辅助手段，可以快速精确定位PHP脚本中可控函数及参数的调用。</li>
<li>缺点：需要人工维护关键字，无法应对变形马，如编码、ASCII运算等等。</li>
</ol>
</li>
<li>帮助我们更加深入地理解PHP内核机制，使我们可以修改PHP源码或者以扩展的形式来动态检测PHP后门/Webshell。（HOOK关键危险函数，如eval, assert等，当GPC参数进入危险函数及有相关危险操作时，判定为后门/Webshell）
<ol>
<li>优点：上面写的缺点取反，并且误报率低，准确。</li>
<li>缺点：部署，维护成本高。</li>
</ol>
</li>
</ol>
<h2> Reference</h2>
<ol>
<li><a href="http://www.laruence.com/2008/08/14/250.html" target="_blank" rel="noopener noreferrer">http://www.laruence.com/2008/08/14/250.html</a></li>
<li><a href="http://blog.pascal-martin.fr/post/php-obtenir-dump-opcodes.html" target="_blank" rel="noopener noreferrer">http://blog.pascal-martin.fr/post/php-obtenir-dump-opcodes.html</a></li>
<li><a href="http://rancoud.com/read-phps-opcode/" target="_blank" rel="noopener noreferrer">http://rancoud.com/read-phps-opcode/</a></li>
<li><a href="http://www.php-internals.com/book/?p=chapt02/02-03-02-opcode" target="_blank" rel="noopener noreferrer">http://www.php-internals.com/book/?p=chapt02/02-03-02-opcode</a></li>
<li><a href="http://security.tencent.com/index.php/blog/msg/19" target="_blank" rel="noopener noreferrer">http://security.tencent.com/index.php/blog/msg/19</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://cdn.jsdelivr.net/gh/MarsAuthority/sec_pic@master/uPic/2023-02/DlYw5G.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>PHP Challenge 2015</title>
      <link>https://mars.run/cybersecurity/PHP_Challenge_2015.html</link>
      <guid>https://mars.run/cybersecurity/PHP_Challenge_2015.html</guid>
      <source url="https://mars.run/rss.xml">PHP Challenge 2015</source>
      <description>背景 在乌云上看到PHP Challenge 2015，深感兴趣，但并无思路，直到看了@Ryat大牛的微博才知道答案。 PHP bug 先贴出代码吧</description>
      <category>网络安全</category>
      <pubDate>Tue, 10 Feb 2015 12:19:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>在乌云上看到<a href="http://zone.wooyun.org/content/22100" target="_blank" rel="noopener noreferrer">PHP Challenge 2015</a>，深感兴趣，但并无思路，直到看了<a href="https://weibo.com/3202054374/CtNpv1ov8?type=comment" target="_blank" rel="noopener noreferrer">@Ryat</a>大牛的微博才知道答案。</p>
<h2> PHP bug</h2>
<p>先贴出代码吧</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照Ryat的提示，找到(<a href="https://bugs.php.net/bug.php?id=69892" target="_blank" rel="noopener noreferrer">https://bugs.php.net/bug.php?id=69892</a>)</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>integer类型的key截断导致不同的数组比较结果相同。我们去看看PHP源码中的相关片段，在<code>Zend/zend_hash.c</code>：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键在34行:</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当数组的key为integer进到这里，比较他们的key是否相同，p1和p2是PHP的bucket结构体，其中h保存着数组的key。bucket结构如下：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出h是ulong，ulong是一个unsigned long，如下：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>看到这里不知道大家有没有看出问题？注意喔，保存p1和p2差值的变量是result，而result是int型变量，这就导致了在64位系统中，unsigned long是64位整型，而int是32位整型，类型的不同出现问题。程序会将<code>p1-&gt;h - p2-&gt;h</code>的结果强制转换为int，我们都知道unsigned long转int会截取低4个字节。所以只需要让unsigned long的低4字节为0，它转换后的int就为0。比如我们将二进制<code>10000000000000000000000000000000000000</code>转换为十进制<code>137438953472</code>，那么<code>137438953472</code>转为int就为0。</p>
<h2> 分析</h2>
<p>现在再来看看这个php代码吧，前面的那个bug利用前提是数组的value相同，key不同，所以首先需要匹配一个md5出来，我在cmd5试了这10个md5，只有第五个<code>06e2b745f3124f7d670f78eabaa94809</code>能解出，原文是<code>hund</code>。于是首先写入cookie：<code>Cookie: user[0]=5;user[1]=hund;</code>&nbsp;程序会进入58行，验证通过，$valid_user被改为true，这个时候输出为<code>Welcome back user</code>。到了这一步答案已经很接近了，只需要将$uid改为0即可。现在试试前面提到的漏洞，我们写入cookie：<code>Cookie: user[137438953472]=5;user[1]=hund;</code>&nbsp;这个时候因为之前提到的漏洞，程序还是会进入58行，因为$input[0]未赋值，所以为NULL，在PHP中<code>0+NULL=0</code>,故成功将$uid改为0。</p>
]]></content:encoded>
    </item>
    <item>
      <title>我用白板墙贴，记录日常生活</title>
      <link>https://mars.run/posts/2023-01-26-whiteboard_gtd.html</link>
      <guid>https://mars.run/posts/2023-01-26-whiteboard_gtd.html</guid>
      <source url="https://mars.run/rss.xml">我用白板墙贴，记录日常生活</source>
      <description>摆脱数字性遗忘：白板墙贴的生活/工作清单，适用于居家办公的 GTD 补充记录方案。 在数字化和网络化的时代，日常记录从纸质转移到电子存储，它带来了无限的容量和随时随地使用的便利。然而，这也带来了新的问题：如果没有打开应用程序，记录就无法提醒，容易忘记重要事情。即使设置了定时提醒，提醒时间也不一定是最佳处理时间，因此可能会延迟或取消，从而导致遗忘。为了解决这个问题，我使用白板墙贴来记录生活/工作清单。 源图：Storyset</description>
      <category>工具</category>
      <pubDate>Sun, 22 Jan 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>摆脱数字性遗忘：白板墙贴的生活/工作清单，适用于居家办公的 GTD 补充记录方案。</p>
</blockquote>
<p>在数字化和网络化的时代，日常记录从纸质转移到电子存储，它带来了无限的容量和随时随地使用的便利。然而，这也带来了新的问题：如果没有打开应用程序，记录就无法提醒，容易忘记重要事情。即使设置了定时提醒，提醒时间也不一定是最佳处理时间，因此可能会延迟或取消，从而导致遗忘。为了解决这个问题，我使用白板墙贴来记录生活/工作清单。</p>
<figure><img src="http://tc.seoipo.com/2023-01-27-05-13-50.png" alt="Website Creator Cartoon" tabindex="0" loading="lazy"><figcaption>源图：Storyset</figcaption></figure>
<h2> 为什么是白板？</h2>
<p>在中学时，我没有电脑和手机，就曾把最初的 GTD 记录在玻璃桌面上，若记录失效或不再需要，只需擦掉即可。白板墙贴与当时的玻璃桌面效果类似，只是换到墙上了。我在书房和走廊各贴了一块白板，书房的墙贴用来提醒当天要做什么，走廊的墙贴用来提醒日常生活仪式。无论走到哪里，都不会错过重要提醒。特别是在不确定下一步该做什么时，我只要转身，就能看到工作清单，非常直观和便捷。</p>
<figure><img src="http://tc.seoipo.com/2023-01-26-12-28-36.png" alt="" tabindex="0" loading="lazy"><figcaption>透明/白色静电墙贴</figcaption></figure>
<p>与电子记录相比，白板没有软件框架限制。它可以用于绘制思维导图，帮助人们更清晰地组织思路；也可以用多种颜色的记号笔随意书写和涂鸦，以原始的方式表达自己的想法。因此，白板是记录、展示信息和思考的极佳工具。</p>
<figure><img src="http://tc.seoipo.com/2023-01-25-19-21-12.png" alt="Scrum board" tabindex="0" loading="lazy"><figcaption>Scrum board</figcaption></figure>
<h2> 白板类型</h2>
<p>白板墙贴源自 @chen 在群里分享的一个很棒的主意：使用静电墙贴作为白板，可以随时记录。在尝试的过程中，我更换了三种材质：透明静电墙贴、白色静电墙贴和 PVC 墙贴（吸磁软白板贴）。</p>
<table>
  <tbody><tr>
    <th>类型</th>
    <th>透明/白板静电墙贴</th>
    <th>PVC 墙贴（非静电）</th>
    <th>支架式白板</th>
  </tr>
  <tr>
    <td>优点</td>
    <td>安装方便；轻松固定在墙上；费用低。</td>
    <td>磁吸；字迹擦拭方便；<br>黑色、白色、绿色、黛灰等多种背景可供选择。</td>
    <td>双面书写；易写易擦；可吸附性；可自由升降；可360°翻转；带刹车滑轮。</td>
  </tr>
  <tr>
    <td>缺点</td>
    <td>字迹在 24 小时后会在墙贴上留下凸起的痕迹；红色、蓝色等非黑色笔迹很难擦干净。</td>
    <td>需要使用双面胶固定；难以将其平整地贴在墙上。</td>
    <td>安装麻烦，无法贴上墙，占地方。</td>
  </tr>
  <tr>
    <td>费用</td>
    <td>20 元（120cm x 200cm）</td>
    <td>160 元（120cm x 200cm）</td>
    <td>280 元（100cm x 200cm）</td>
  </tr>
</tbody></table>
<h2> 我的方案</h2>
<p>在我的方案中，记录的想法分为日常仪式和生活/工作两类。日常仪式记录在走廊白板上，生活/工作记录则输出在书房白板上。下面我将简要介绍白板内容和思路。</p>
<figure><img src="http://tc.seoipo.com/2023-02-03-20-58-05.png" alt="" tabindex="0" loading="lazy"><figcaption>记录输入流</figcaption></figure>
<h3> 书房白板</h3>
<p>我最常待的地方是书房，所以把日常记录都放在书房白板上，用来记录当日清单、锻炼进度、思维导图、项目跟进和临时安排。书房白板使用率较高，因此建议使用易写易擦的 PVC 墙贴（吸磁软白板贴）。</p>
<figure><img src="http://tc.seoipo.com/2023-01-23-20-58-00.png" alt="" tabindex="0" loading="lazy"><figcaption>书房白板</figcaption></figure>
<figure><img src="http://tc.seoipo.com/2023-01-28-10-42-47.png" alt="" tabindex="0" loading="lazy"><figcaption>PVC 墙贴（非静电）</figcaption></figure>
<h3> 走廊白板</h3>
<p>走廊白板是对书房白板的补充，可以在书房之外的区域提醒生活仪式等内容，例如：每天早上喝杯热水自测体脂，晚上进行当日回顾和睡前准备。走廊白板擦写频率较低，可以使用便宜的静电墙贴。如果需要修改走廊白板的提示，可以用纸巾沾水擦拭。</p>
<figure><img src="http://tc.seoipo.com/2023-01-23-20-53-36.png" alt="" tabindex="0" loading="lazy"><figcaption>走廊白板</figcaption></figure>
<h3> 电子记录</h3>
<p>使用白板墙贴记录 GTD 并不意味着放弃数字化记录。相反，我可以将白板墙贴与电子记录结合起来，使用电子记录来存储详细信息，而使用白板墙贴来提醒重要事项。在「当日检视」的环节中，我会同步书房白板和电子 GTD，以确保两者的内容保持一致。这样，我就可以在保持良好的效率和组织性的同时，还可以提高记录的可靠性和可追溯性。</p>
<h2> 更多</h2>
<p>通过使用白板墙贴记录 GTD，我发现它不仅可以帮助我更好地管理时间和任务，还可以提高工作效率。因为白板墙贴是实体物品，我可以随时随地看到它，而且它是直观的，使我一目了然地了解自己的任务和进度。此外，白板墙贴可以随时更新和修改，让我可以随时调整计划和任务。白板工具填补了笔记/清单应用和个人定制需求之间的空隙。</p>
]]></content:encoded>
    </item>
    <item>
      <title>直播入门攻略零 | 硬件篇：直播设备</title>
      <link>https://mars.run/apps/livestreaming/0_live_equipments.html</link>
      <guid>https://mars.run/apps/livestreaming/0_live_equipments.html</guid>
      <source url="https://mars.run/rss.xml">直播入门攻略零 | 硬件篇：直播设备</source>
      <description>直播已经成为一种主流的传播方式，几乎所有的行业都会使用它。经过两年的持续直播，我总结出了一套直播入门攻略，从设备、软件和技巧三个方面，帮助你快速入门直播，开始自己的直播之旅。 本文是直播入门攻略的前置篇，主要介绍直播所需的设备，以及如何避免购买不必要的高价设备。直播设备可分为电脑、补光灯、稳定器（三脚架）、音频采集（收音器）和视频采集（摄像头）。 电脑 OBS 直播对电脑配置要求较高，建议使用三年内购买的主流配置台式机。台机推荐预算在一万元以上，显卡为 3060 以上，内存为 32G。 补光灯 露脸主播一定要配柔光灯或环形灯，可以提升颜值。如果带眼镜的话，可以用小型补光灯代替环形灯，以免反射出光圈影响视觉。补光灯可以放在正面 45 度成蝴蝶光（派拉蒙光），可以显瘦显轮廓；背后可以使用辅助光或一张白纸反光，以防止正面灯光太亮。</description>
      <category>工具</category>
      <pubDate>Thu, 12 Jan 2023 16:55:27 GMT</pubDate>
      <content:encoded><![CDATA[<p>直播已经成为一种主流的传播方式，几乎所有的行业都会使用它。经过两年的持续直播，我总结出了一套直播入门攻略，从设备、软件和技巧三个方面，帮助你快速入门直播，开始自己的直播之旅。</p>
<p>本文是直播入门攻略的前置篇，主要介绍直播所需的设备，以及如何避免购买不必要的高价设备。直播设备可分为电脑、补光灯、稳定器（三脚架）、音频采集（收音器）和视频采集（摄像头）。</p>
<h2> 电脑</h2>
<p>OBS 直播对电脑配置要求较高，建议使用三年内购买的主流配置台式机。台机推荐预算在一万元以上，显卡为 3060 以上，内存为 32G。</p>
<h2> 补光灯</h2>
<p>露脸主播一定要配柔光灯或环形灯，可以提升颜值。如果带眼镜的话，可以用小型补光灯代替环形灯，以免反射出光圈影响视觉。补光灯可以放在正面 45 度成蝴蝶光（派拉蒙光），可以显瘦显轮廓；背后可以使用辅助光或一张白纸反光，以防止正面灯光太亮。</p>
<h2> 三脚架</h2>
<p>三脚架主要有两类：桌面款，建议高度为 55cm；站立款，建议高度为 210cm。价位从 10-500 元不等，效果无明显区别，新手用户的三脚架预算建议不要超过 100 元。</p>
<h2> 音频采集</h2>
<p>收音设备的费用从几元到几千元不等。手机的收音性能比绝大多数话筒好，如果你使用手机摄像方案，可以先不用购买收音器材。</p>
<p>廉价麦克风存在收音范围窄、不清晰、多噪音等问题，但价格低廉、使用方便，适合新人测试使用。</p>
<p>桌面直播多使用「声卡 + 话筒」方案，预算需要超过一千元。不要购买廉价的山寨声卡，还不如手机收音来得清晰。</p>
<p>外出直播或进阶用户推荐 RODE 或 DJI 的无线麦克风，这两款音频水准都可以吊打同行。RODE 是老牌话筒厂家，音质有保障；DJI 麦克风推出不久，但集百家之长，设计非常人性化，小白使用也很方便。</p>
<h2> 视频采集</h2>
<p>桌面摄像头、手机和微单相机都可以作为直播的视频采集来源。</p>
<h3> 摄像头</h3>
<p>桌面摄像头的价格在 50-1000 元不等，但实际效果没有太大的区别。个人体验过罗技 C930 后，发现画面模糊不清晰，将问题反馈给客服后得知，画质不清晰是桌面摄像头的通病。</p>
<p>不管是几十元的廉价摄像头还是上千元的罗技 C1000，它们的实际像素都<strong>只有 200 万</strong>。宣传中的 2000 万像素是通过软件放大的效果，画质并没有实质性的变化。入门用户可以选择 100 元的自动变焦摄像头。</p>
<p>桌面摄像头搭配三角架可以调整更佳的角度，购买时要注意摄像头是否有<strong>三脚架接口</strong>。</p>
<h3> 手机</h3>
<p>如果室内没有桌面摄像头，而又想用电脑做直播推流，可以考虑用手机替代摄像头，步骤可参考下方介绍。</p>
<h3> 相机</h3>
<p>相比摄像头的算法像素效果，只有相机才能达到真正意义上的高清直播。</p>
<p>如果你的相机有外接视频接口（例如：HDMI、mini HDMI、SDI），可以通过视频采集卡将相机视频转为直播视频传入电脑。索尼、佳能等主流相机都有专门的直播软件，不需要采集卡就可以直接连接电脑进行直播。运动相机 GoPro 也已经支持相机直播传输，希望国内厂商也能跟上。</p>
<p>将相机用作摄像头的费用较高，一般需要几千到几万，只建议已购买相机的主播采用此方案。</p>
<h2> 手机作摄像头</h2>
<h3> Camo</h3>
<p><a href="https://apps.apple.com/app/reincubate-camo/id1514199064?platform=iphone" target="_blank" rel="noopener noreferrer">Camo</a> 专用于 iOS 设备，连接数据线后可将 iPhone 或 iPad 变为直播摄像头。</p>
<h3> NDI</h3>
<p>NDI 是最稳定的，可自由调节拍摄参数。打开 NDI 应用后，需等待 NDI 界面周边出现绿框或红框，OBS 才可以识别到摄像头。不过 NDI 是收费应用，安卓用户可使用 <a href="https://wwe.lanzoup.com/iQCMh00b946b" target="_blank" rel="noopener noreferrer">NDI 调试 APK</a>。</p>
<h3> IP Webcam</h3>
<p>IP Webcam 的推流稳定性一般，容易掉帧，但 <a href="https://wwz.lanzouf.com/iT6pH01tj7yb" target="_blank" rel="noopener noreferrer">IP Webcam 免费版</a>足够个人使用。</p>
<p>下文为 IP Webcam 基础设置：</p>
<ul>
<li>进入 IP Webcam 设置页面，将流质量调整至 90%，视频分辨率设为 720p，可有效减少卡顿。IP camera 耗电低，适合手机长时间直播，支持视频与浏览器等方式。</li>
<li>在 OBS 中，选择「场景」&gt;「来源」&gt;「媒体源」，取消勾选本地文件，「输入」项中填入 IP Webcam 视频地址，例如 <code>http://192.168.2.234:8080/video</code>。</li>
<li>OBS 中选择「场景」&gt;「来源」&gt;「浏览器」，「URL」项中填入 IP Webcam 浏览器全屏地址，例如 <code>http://192.168.2.234:8080/jsfs.html</code>。注意：浏览器推流容易出现闪屏。</li>
</ul>
<h3> 其他</h3>
<p>如果出现闪退等问题，可尝试 iriun webcam、DroidCam 和 ivcam。</p>
<p>不推荐使用无他伴侣，尽管国内有大量教程介绍它，但使用中会出现很多问题，例如：摄影角度很难控制；无法使用 FaceRig 等变脸应用；直播 10 分钟后，摄像头经常自动与 OBS 断开连接；直播 2 小时后，OBS 无法检测到无他伴侣。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>